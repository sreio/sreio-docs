import{_ as i,c as e,e as s,o as t}from"./app-DDsjqNbb.js";const c="/assets/1-qfp9GWQl.png",p="/assets/2-ubBhjfXP.png",o="/assets/3-D3lrETmz.png",d="/assets/4-T8EWJAyo.png",n="/assets/5-ClBwiY3f.png",r="/assets/6-CspHKZKq.png",l="/assets/7-BdvCUeDF.png",h="/assets/8-CIS6SEY7.png",g="/assets/9-DBje3qFx.png",k="/assets/10-DxLz7arJ.png",m="/assets/11-BJFtPYl1.png",y="/assets/12-2kQ7oFdI.png",f={};function b(u,a){return t(),e("div",null,a[0]||(a[0]=[s('<p>转自：<a href="https://mp.weixin.qq.com/s/fHmxixegZEBYh5T1focIQA" target="_blank" rel="noopener noreferrer">mysql 的 varchar 字段最大长度真的是 65535吗？</a></p><p>在mysql建表sql里，我们经常会有定义<code>字符串</code>类型的需求。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">CREATE</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> TABLE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> `</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">user</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">` (</span></span>\n<span class="line"><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">  `</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">name</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">`</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> varchar</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">100</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">) </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">NOT NULL</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> DEFAULT</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;&#39;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> COMMENT </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">名字</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span></span>\n<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">) ENGINE</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">InnoDB </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">DEFAULT</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> CHARSET</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">utf8mb4 ;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比方说user表里的名字，就是个字符串。mysql里有两个<code>类型</code>比较适合这个场景。</p><p><code>char</code>和<code>varchar</code>。</p><p>声明它们都需要在字段边上加个数组，比如<code>char(100)</code>和<code>varchar(100)</code>，这个100是指当前字段能放的<code>最大字符数</code>。</p><p><code>char</code>和<code>varchar</code>的区别在于，<code>varchar</code>虽然声明了最大能放100个字符，但一开始不需要分配100个字符的空间，可以根据需要慢慢增加空间。而<code>char</code>一开始声明是多少，就固定预留多少空间。</p><p>所以，varchar比起char更省空间，一般没啥大事，大家都爱用<code>varchar</code>。</p><p>那问题来了，声明<code>varchar</code>字段时，它的最大长度是多少呢？</p><p>相信大家应该听说过<code>varchar</code>字段的最大长度是<code>65535</code>吧。</p><p>没听过也没关系，你现在听到了。</p><p>但实际上是这样吗？</p><p>我们来做个实验。</p><h2 id="varchar最大值是多少" tabindex="-1"><a class="header-anchor" href="#varchar最大值是多少"><span>varchar最大值是多少</span></a></h2><p>我们直接拿65535来试一下。</p><figure><img src="'+c+'" alt="1" tabindex="0" loading="lazy" width="1080" height="264"><figcaption>1</figcaption></figure><p>很明显报错了。长度为65535的varchar报错</p><p>报错内容也说了, 由于列长度过大导致报错，最长是<code>16383</code>。</p><p>把上面的65535改成 16383，确实是成功了。</p><p>哦？所以说varchar最大值是16383？</p><p>当然不是。</p><p>这其实还有好几个因素影响这这个最大值。</p><h2 id="不同字符集的影响" tabindex="-1"><a class="header-anchor" href="#不同字符集的影响"><span>不同字符集的影响</span></a></h2><p>varchar里放的是字符串，而字符串看起来可以是英文字母，也可以是数字或中文。但不管怎么样，都可以把这样的中英文数字转成二进制的01串。</p><p>按照一定规则把符号和二进制码对应起来，这就是<code>编码</code>。而把n多这种已经编码的字符聚在一起，就是我们常说的<code>字符集</code>。</p><p>建表语句里有个<code>CHARSET</code>，这里填的是<code>字符集</code>。</p><p>不同的字符集要求使用的字节个数也不同，我们可以通过 <code>show charset</code>; 看到mysql支持哪些字符集，以及这些字符集里<code>存储一个字符所需的最大字节数（Maxlen）</code>。</p><figure><img src="'+p+'" alt="2" tabindex="0" loading="lazy" width="1080" height="371"><figcaption>2</figcaption></figure><p>查看mysql支持哪些charset</p><p>我们尝试下把建表sql语句里的CHARSET改一改，比如改成<code>utf8mb3</code>。</p><p>我们再执行下，会发现，最大值又不一样了。</p><figure><img src="'+o+'" alt="2" tabindex="0" loading="lazy" width="1080" height="264"><figcaption>2</figcaption></figure><p>utf8mb3下的报错 并且，上面虽然提示<code>max=21845</code>，但要是真执行起来会发现还是报错。在改为<code>21844之后才成功</code>。</p><p>不讲武德。再把字符集改为 <code>latin1</code>。会发现，最大值会是 <code>65533</code>。</p><figure><img src="'+d+'" alt="2" tabindex="0" loading="lazy" width="1080" height="273"><figcaption>2</figcaption></figure><p>varchar为65533时创建成功</p><p>这里渐渐可以发现规律。</p><ul><li><p>utf8mb4的maxlen=4，对应varchar最大长度=16383。4*16383 = 65532。</p></li><li><p>utf8mb3的maxlen=3，对应varchar最大长度=21844。3*21844 = 65532。</p></li><li><p>latin1的maxlen=1，对应varchar最大长度=65533。 1 * 65533 = 65533。</p></li></ul><p>也就是说varchar边上的长度代表的是这一列能放的最大<code>字符数</code>，而maxlen代表单个字符占用的最大<code>字节数</code>。相乘的结果很接近65535。说明<code>65535是指的字节数</code>，而不是<code>字符数</code>。</p><p>也就是说varchar的最大长度，根据选择的字符集的不同，会有区别。</p><p>总的来说接近于 <code>65535</code> 除以 <code>字符集</code>的maxlen。</p><p><code>但其实这样还不够严谨</code>。还有其他影响因素。</p><h2 id="是否可以为null的影响" tabindex="-1"><a class="header-anchor" href="#是否可以为null的影响"><span>是否可以为NULL的影响</span></a></h2><p>上面的建表语句里声明了test字段都是<code>NOT NULL</code>，也就是非空，如果我们将这个改成可以为NULL，再用 <code>CHARSET=latin1</code>去试试。这时候就会发现，前面NOT NULL的时候最大能使用65533去建表，现在报错了。</p><p>改成65532，就能成功了，也就是最长<code>长度少了1个字节</code>。</p><figure><img src="'+n+'" alt="2" tabindex="0" loading="lazy" width="1020" height="328"><figcaption>2</figcaption></figure><p>这是因为一个字段是否为NULL这件事情，是需要<code>一个字节</code>去记录下来的。</p><p>而当字段为<code>NOT NULL</code>的时候，则可以省下这个字节。</p><h2 id="列数的影响" tabindex="-1"><a class="header-anchor" href="#列数的影响"><span>列数的影响</span></a></h2><p>上面提到的情况都是在表里只有一列时的结果，当我们表里<code>有更多的列</code>时，我们会发现varchar的最大值还会有变化。比如同样还是latin1字符集，我们再增加一列varchar类型，并且用的还是前面允许的最大值65533。</p><p>结果发现这次会失败。</p><figure><img src="'+r+'" alt="2" tabindex="0" loading="lazy" width="1080" height="298"><figcaption>2</figcaption></figure><p>查了一下资料发现，原来65535是mysql单行的最大长度（不包含blob和text等类型的情况下）</p><p>mysql表里单行中的<code>所有列加起来</code>（不考虑其他隐藏列和记录头信息） ，占用的最大长度是65535个字节。</p><p><code>注意上面加粗的部分，加起来不超过65535</code>。</p><p>比如如果还有int的列，那它占用4个字节，bigint占用8个字节，字段越多，留给单个varchar列的空间就越少。</p><p>因此，<code>前面提到的 varchar 的最大长度，接近于 65535 除以 字符集的maxlen，但前提是只有一列not null 的varchar类型的字段</code>。</p><h2 id="为什么不是65535而是65533" tabindex="-1"><a class="header-anchor" href="#为什么不是65535而是65533"><span>为什么不是65535而是65533？</span></a></h2><p>不过问题又来了，上面建表sql里，不管是那种字符集，最后得到的字符数都约等于65533。</p><p>但数据库单行最大值应该是65535。<code>65535 - 65533 = 2</code> 。这里面还差了个2，为什么呢？</p><p>这就要聊一下mysql单行里数据到底是怎么存储的。</p><h3 id="数据表行存储的格式" tabindex="-1"><a class="header-anchor" href="#数据表行存储的格式"><span>数据表行存储的格式</span></a></h3><p>我们可以通过 <code>show table status</code> 命令，查看到当前表格使用的行格式。</p><figure><img src="'+l+'" alt="2" tabindex="0" loading="lazy" width="1080" height="870"><figcaption>2</figcaption></figure><p>通过上面的 <code>Row_format</code> 字段可以看到这个表用的是 <code>Dynamic</code> 行格式。</p><p>事实上，现在的mysql数据表一般都是采用Dynamic行记录格式。</p><p>我们来看下<code>Dynamic</code>行格式长什么样子。</p><figure><img src="'+h+'" alt="2" tabindex="0" loading="lazy" width="1080" height="302"><figcaption>2</figcaption></figure><p>Dynamic格式将行记录分为两部分，分为是<code>行记录的额外信息</code>和<code>行记录的真实数据</code>。</p><p><code>行记录的额外信息</code>：</p><ul><li><p><code>变长字段长度列表</code>：指的是varchar，text，blob这种类型，它们属于变长字段，这里表示的就是这些字段的长度。</p></li><li><p><code>NULL值列表</code>：用来记录当前行里哪些列是为null的。如果全部列都是not null的话，那就不需要有这个字段。</p></li><li><p><code>记录头信息</code>：这是固定5个字节，用来记录一些特殊的信息，比如这一行是否被删了，这一行在这个16k的数据页内是不是最小的，以及指向下一条记录的指针之类的一些信息，不需要太关注。</p></li></ul><p><code>行记录的真实数据</code>：</p><p>里面放的就是一行里，每一列的真正内容。除了我们建表时里涉及到的列以外，还有一些隐藏列。</p><p>比如Row_ID，这个是在建表是没有声明主键时，数据表自动会生成的隐藏主键。另外还有<code>trx_id</code>字段，用于记录当前这一行数据行是被<code>哪个事务</code>修改的，和一个<code>roll_pointer</code>字段，这个字段是用来指向当前这个数据行的上一个版本，通过这个字段，可以为这行数据形成一条版本链，从而实现<code>多版本并发控制（MVCC）</code>。有没有很眼熟，这个在之前写的<a href="https://mp.weixin.qq.com/s?__biz=Mzg5NDY2MDk4Mw==&amp;mid=2247488340&amp;idx=1&amp;sn=6c5a0743918d582eb6ee76571d992897&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">文章</a>里出现过。</p><figure><img src="'+g+'" alt="2" tabindex="0" loading="lazy" width="1080" height="665"><figcaption>2</figcaption></figure><p>所以我们回过头来看我们建的表，当只有一列not null的 varchar字段时，行记录长下面这样。</p><figure><img src="'+k+'" alt="2" tabindex="0" loading="lazy" width="1080" height="302"><figcaption>2</figcaption></figure><p>前面提到，行最大值65535字节是不包含隐藏列和记录头信息的，所以其实是指上图中红色的部分。</p><p>而最左边的<code>变长字段长度列表</code>中，为了表示varchar列的长度，占用了<code>两个字节</code>，也就是16位，2的16次方，最大可以表示65535的长度，正好足够用来表示varchar列当前的长度是65533。</p><p>所以<code>65535 - 65533 = 2</code> 。这里面差的2，是用来<code>存varchar字段长度</code>去了。</p><h2 id="一个页才16k-怎么保存65533-64k-数据" tabindex="-1"><a class="header-anchor" href="#一个页才16k-怎么保存65533-64k-数据"><span>一个页才16k，怎么保存65533（64k）数据？</span></a></h2><p>之前的文章里其实多次提到了mysql底层是以页的形式去存储数据的，而一个页固定16k，而一个varchar字段最大能放65533字节数据，换算一下大概是64k，整整4个16k的页。</p><figure><img src="'+m+'" alt="2" tabindex="0" loading="lazy" width="860" height="620"><figcaption>2</figcaption></figure><p>这里面是怎么实现的？</p><p>对于这种情况，其实行数据里针对这个超大的varchar字段只保存个20字节的指针（实际上是个偏移量），这个指针会指向新的页（off page），这些页里保存的是实际的varchar字段里的65533字节数据。这种由于字段过长导致需要额外的页来保存数据的现象叫<code>行溢出</code>。</p><figure><img src="'+y+'" alt="2" tabindex="0" loading="lazy" width="1080" height="432"><figcaption>2</figcaption></figure><h2 id="大于64k的字符串该怎么处理" tabindex="-1"><a class="header-anchor" href="#大于64k的字符串该怎么处理"><span>大于64k的字符串该怎么处理？</span></a></h2><p>如果离谱点，数据量更大，比64k还大，这时候就不能继续用varchar了，需要改用text和blob类型字段。</p><p>而text和blob类型本身也是分TINY、MEDIUM，LONG三个档位的，对应着不同的数据长度，最大到4G左右。</p><p>像下面这样就可以将数据类型定义为LONGTEXT。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">CREATE</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> TABLE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> `</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">test_max_length</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">` (</span></span>\n<span class="line"><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">  `</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">test</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">`</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> LONGTEXT </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">NOT NULL</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> COMMENT </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">测试长度字段</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span></span>\n<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">) ENGINE</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">InnoDB </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">DEFAULT</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> CHARSET</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">latin1 ;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而他们的存储方式也跟varchar的情况类似，只保存20个字节的指针，实际数据保存在其他溢出页里。</p><p>以前我们查某一行数据，他们都在一个16k的数据页里，查询时只要一次磁盘IO就能将这个数据页读取出来。</p><p>当一个数据库里某行数据里有个特别大的字符串时，我们如果还想把整行数据给读出来，那我们还得把<code>off page</code>的数据给全部读出来，这意味着<code>更多的磁盘IO，性能就更差</code>了。</p><p>为了规避这个问题，我们写<code>select sql</code>的时候，如果发现某列字段，是个特别长的字符串时，能不读它就尽量不加到select里，这也是为什么大家<code>不建议使用select * from table的原因</code>。</p><h3 id="blob和text的区别" tabindex="-1"><a class="header-anchor" href="#blob和text的区别"><span>blob和text的区别</span></a></h3><p>一般来说，blob和text都可以用来放超长字符串。但它们会有一点点区别。</p><p>我们知道字符集（charset）下还有个<code>校对规则（collation）</code>的概念，比如同样是a，大写A和小写a能不能算作是一个字符，这会影响比较和排序，collation就是定义这个规则用的。</p><p><code>blob没有字符集的概念，而text有</code>。这意味如果用blob来存文本的话，就没法用字符集的校对规则来排序和做比较。</p><p>还有一个区别，blob还能保存二进制数据，比如压缩过的文本数据，图片或者视频，别笑，虽然不合适，但我确实见过有人拿它来保存视频。。。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ul><li><p>现在的mysql数据表一般采用<code>Dynamic</code>行记录格式。它由<code>行记录的额外信息</code>和<code>行记录的真实数据</code>组成。</p></li><li><p>mysql表里单行中的<code>所有列加起来</code>（不考虑其他隐藏列和记录头信息） ，占用的<code>最大长度是65535个字节</code>。</p></li><li><p>如果数据表里只有一列 <code>not null</code> 的<code>varchar</code>字段，它的最大长度，接近于 <code>65535</code> 除以 <code>字符集的maxlen</code>。</p></li><li><p>如果要存放<code>大于64k</code>的字段数据，可以考虑使用<code>longtext</code>和<code>longblob</code>等类型。</p></li><li><p>mysql的数据页大小是16k，为了保存varchar或者text，<code>blob</code>这种长度可能大于16k的字段，在<code>Dynamic</code>行格式中，会只保留<code>20个字节</code>的指针，实际数据则放在<code>其他溢出页</code>中。为了将它们读取出来，会需要更多的磁盘IO。</p></li><li><p>blob和text很像，但blob没有字符集的概念，并且还能存放<code>二进制</code>的数据，比如图片或视频，但实际上图片和视频更推荐放在对象存储（Object Storage Service，简称oss）中。</p></li></ul>',102)]))}const A=i(f,[["render",b]]),E=JSON.parse('{"path":"/mysql/%E5%AE%9E%E8%B7%B5%E6%8A%80%E5%B7%A7/varchar_maxlen/","title":"varchar最大字符串","lang":"zh-CN","frontmatter":{"title":"varchar最大字符串","createTime":"2025/07/07 17:56:31","permalink":"/mysql/实践技巧/varchar_maxlen/","description":"转自：mysql 的 varchar 字段最大长度真的是 65535吗？ 在mysql建表sql里，我们经常会有定义字符串类型的需求。 比方说user表里的名字，就是个字符串。mysql里有两个类型比较适合这个场景。 char和varchar。 声明它们都需要在字段边上加个数组，比如char(100)和varchar(100)，这个100是指当前字段能...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"varchar最大字符串\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-07T10:46:08.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://docs.sreio.com/mysql/%E5%AE%9E%E8%B7%B5%E6%8A%80%E5%B7%A7/varchar_maxlen/"}],["meta",{"property":"og:site_name","content":"Sreio Docs"}],["meta",{"property":"og:title","content":"varchar最大字符串"}],["meta",{"property":"og:description","content":"转自：mysql 的 varchar 字段最大长度真的是 65535吗？ 在mysql建表sql里，我们经常会有定义字符串类型的需求。 比方说user表里的名字，就是个字符串。mysql里有两个类型比较适合这个场景。 char和varchar。 声明它们都需要在字段边上加个数组，比如char(100)和varchar(100)，这个100是指当前字段能..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-07T10:46:08.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-07T10:46:08.000Z"}]]},"readingTime":{"minutes":10.21,"words":3062},"git":{"createdTime":1751885168000,"updatedTime":1751885168000,"contributors":[{"name":"sreio","username":"sreio","email":"ingwei@163.com","commits":1,"avatar":"https://avatars.githubusercontent.com/sreio?v=4","url":"https://github.com/sreio"}],"changelog":[{"hash":"c1ab990bb57919c348cc77b4236368714def9959","time":1751885168000,"email":"ingwei@163.com","author":"sreio","message":"elk&#x26;clickhouse&#x26;redis&#x26;mongdb&#x26;etcd"}]},"autoDesc":true,"filePathRelative":"mysql/3.实践技巧/3.varchar_maxlen.md","headers":[]}');export{A as comp,E as data};
