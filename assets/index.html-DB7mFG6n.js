import{_ as e,c as i,e as t,o as n}from"./app-DDsjqNbb.js";const c={};function p(d,a){return n(),i("div",null,a[0]||(a[0]=[t('<h2 id="_1-rabbitmq核心概念有哪些" tabindex="-1"><a class="header-anchor" href="#_1-rabbitmq核心概念有哪些"><span>1.RabbitMQ核心概念有哪些？</span></a></h2><ul><li><code>Broker：</code> 表示消息队列服务器</li><li><code>Exchange：</code> 消息交换机，它指定消息按什么规则，路由到哪个队列</li><li><code>Queue：</code> 消息队列载体，每个消息都会被投入到一个或多个队列</li><li><code>Binding：</code> 绑定，它的作用就是把exchange和queue按照路由规则绑定起来</li><li><code>Routing Key：</code> 路由关键字，exchange根据这个关键字进行消息投递</li><li><code>VHost：</code> vhost 可以理解为虚拟 broker ，包含：一批交换机，消息队列和相关的对象。</li><li><code>Producer：</code> 消息生产者，就是投递消息的程序</li><li><code>Consumer：</code> 消息消费者，就是接受消息的程序</li><li><code>Channel：</code> 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务</li></ul><h2 id="_2-rabbitmq有哪些使用场景" tabindex="-1"><a class="header-anchor" href="#_2-rabbitmq有哪些使用场景"><span>2.RabbitMQ有哪些使用场景？</span></a></h2><p>RabbitMQ有哪些使用场景或者你们业务都什么地方使用MQ，其实都是一类问题。</p><p>RabbitMQ主要的应用场景如下：</p><ul><li><code>异步任务</code>:将业务中属于非核心或不重要的流程部分，使用消息异步通知的方式发给目标系统，这样主业务流程无需同步等待其他系统的处理结果，从而达到系统快速响应的目的。</li><li><code>服务间异步通信</code>:多个服务之间或者系统之间，通过消息互相通信，就大家平时跟朋友互发短信差不多。</li><li><code>应用解耦</code>:基于消息订阅机制实现业务扩展，例如：电商下单场景，用户下单之后，产生一条订单消息，然后仓库模块订阅订单消息发货、积分模块可以订阅订单消息增加积分、短信模块可用订阅订单消息发送短信等等。</li><li><code>顺序消费</code>:业务层面需要排队处理的场景，例如：活动报名，名额有限，先到先得。</li><li><code>定时任务</code>:通过消息队列的延迟消息机制，可以实现定时执行任务的效果，例如：订单15分钟内未支付，则关闭订单，下单的时候发送一条延迟15分钟的消息，15分钟后消息才会投递给消费者处理。 <blockquote><p>提示：详情可以参考延迟队列章节。</p></blockquote></li><li><code>请求削峰</code>:因为上下游系统之间处理流量的能力存在差异，消息队列可以起到调节作用，让下游系统可以匀速处理流量，跟排队挤地铁是一个意思，因为地铁站的吞吐量有限，一下子无法容纳太多人，通过排队进站的方式，可以避免地铁站超负荷，维持在一个稳定运转的状态。</li></ul><h2 id="_3-为什么使用mq-mq的优点有那些" tabindex="-1"><a class="header-anchor" href="#_3-为什么使用mq-mq的优点有那些"><span>3.为什么使用MQ？MQ的优点有那些?</span></a></h2><h3 id="简答" tabindex="-1"><a class="header-anchor" href="#简答"><span>简答</span></a></h3><ul><li><code>异步处理</code> - 相比于传统的串行、并行方式，提高了系统吞吐量。</li><li><code>应用解耦</code> - 系统间通过消息通信，不用关心其他系统的处理。</li><li><code>流量削锋</code> - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。</li><li><code>日志处理</code> - 解决大量日志传输。</li><li><code>消息通讯</code> - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</li></ul><h3 id="详答" tabindex="-1"><a class="header-anchor" href="#详答"><span>详答</span></a></h3><p>主要是：解耦、异步、削峰三个方面讲解。</p><h4 id="解耦" tabindex="-1"><a class="header-anchor" href="#解耦"><span>解耦</span></a></h4><p>A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃…A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</p><p>就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦。</p><h4 id="异步" tabindex="-1"><a class="header-anchor" href="#异步"><span>异步</span></a></h4><p>A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求。如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms。</p><h4 id="削峰" tabindex="-1"><a class="header-anchor" href="#削峰"><span>削峰</span></a></h4><p>减少高峰时期对服务器压力。</p><h2 id="_4-系统引入rabbitmq有什么缺点" tabindex="-1"><a class="header-anchor" href="#_4-系统引入rabbitmq有什么缺点"><span>4.系统引入RabbitMQ有什么缺点？</span></a></h2><p>总体上项目引入RabbitMQ会带来下面三个方面的影响</p><h3 id="系统可用性降低" tabindex="-1"><a class="header-anchor" href="#系统可用性降低"><span>系统可用性降低</span></a></h3><p>因为项目增加了RabbitMQ这个服务组件，RabbitMQ自己本身不稳定或者挂了，我们系统也会受影响，所以系统可用性会降低，总体上引入的服务组件越多，要维护的东西越多，不稳定的因素越多，相对于什么都不用，或者少用的项目来说系统的可用性是有所下降的。</p><h3 id="系统复杂度提高" tabindex="-1"><a class="header-anchor" href="#系统复杂度提高"><span>系统复杂度提高</span></a></h3><p>加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，复杂性增大。</p><h3 id="一致性问题" tabindex="-1"><a class="header-anchor" href="#一致性问题"><span>一致性问题</span></a></h3><p>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。</p><p>总体上引入RabbitMQ消息队列有好处，也带来了一些问题，需要权衡利弊</p><h2 id="_5-消息如何路由-有几种交换机类型" tabindex="-1"><a class="header-anchor" href="#_5-消息如何路由-有几种交换机类型"><span>5.消息如何路由（有几种交换机类型）？</span></a></h2><p>RabbitMQ消息如何路由、消息如何投递跟交换机（exchange）类型有关，不同的交换机类型消息路由策略不一样。</p><p>RabbitMQ常用的交换机如下：</p><ul><li>Direct类型</li><li>Topic 类型</li><li>Fanout 类型</li></ul><p>下面是不同交换机的消息路由策略：</p><ul><li>direct：如果路由键完全匹配，消息就被投递到相应的队列</li><li>topic：跟direct类似，区别是路由键支持通配符。</li><li>fanout：如果交换器收到消息，将会广播到所有绑定的队列上</li></ul><h2 id="_6-rabbitmq有几种工作模式" tabindex="-1"><a class="header-anchor" href="#_6-rabbitmq有几种工作模式"><span>6.RabbitMQ有几种工作模式？</span></a></h2><p>RabbitMQ有几种工作模式？</p><p>根据交换机类型和消费者数量的不同，RabbitMQ有下面几种工作模式：</p><ul><li><code>简单队列</code>:一个消息生产者，一个消息消费者</li><li><code>Work队列</code>:一个生产者，多个消费者</li><li><code>发布订阅模式</code>:发布订阅模式，就是一个生产者发送的消息会被多个消费者获取，因为一条消息会被多个消费者分别消费处理，所以也叫广播模式、一对多模式。</li><li><code>路由模式</code>:RabbitMQ路由模式大体上跟发布订阅模式一样，区别在于发布订阅模式将消息转发给所有绑定的队列，而路由模式将消息转发给那个队列是根据路由匹配情况决定的。</li><li><code>主题模式</code>:RabbitMQ主题模式(Topic)跟路由模式类似，区别在于主题模式的路由匹配支持通配符模糊匹配，而路由模式仅支持完全匹配。</li></ul><h2 id="_7-如何解决消息的顺序问题" tabindex="-1"><a class="header-anchor" href="#_7-如何解决消息的顺序问题"><span>7.如何解决消息的顺序问题？</span></a></h2><p>RabbitMQ的消息顺序问题，需要分三个环节看待，发送消息的顺序、队列中消息的顺序、消费消息的顺序。</p><h3 id="发送消息的顺序" tabindex="-1"><a class="header-anchor" href="#发送消息的顺序"><span>发送消息的顺序</span></a></h3><p>消息发送端的顺序，大部分业务不做要求，谁先发消息无所谓，如果遇到业务一定要发送消息也确保顺序，那意味着，只能全局加锁一个个的操作，一个个的发消息，不能并发发送消息。</p><h3 id="队列中消息的顺序" tabindex="-1"><a class="header-anchor" href="#队列中消息的顺序"><span>队列中消息的顺序</span></a></h3><p>RabbitMQ中，消息最终会保存在队列中，在同一个队列中，消息是顺序的，先进先出原则，这个由Rabbitmq保证，不同队列中的消息顺序，是没有保证的，例如：进地铁站的时候，排了三个队伍，不同队伍之间的，不能确保谁先进站。</p><h3 id="消费消息的顺序" tabindex="-1"><a class="header-anchor" href="#消费消息的顺序"><span>消费消息的顺序</span></a></h3><p>在多个消费者消费同一个消息队列的场景，通常是无法保证消息顺序的。</p><p>例如：消息A、B、C按顺序进入队列，消费者A1拿到消息A、消费者B1拿到消息B, 结果消费者B执行速度快，就跑完了，又或者消费者A1挂了，都会导致消息顺序不一致。</p><div class="hint-container tip"><p class="hint-container-title">解决消费顺序的问题，通常就是一个队列只有一个消费者</p></div><p>这样就可以一个个消息按顺序处理，缺点就是并发能力下降了，无法并发消费消息，这是个取舍问题。</p><h2 id="_8-如何处理重复消息-即消息幂等性保证" tabindex="-1"><a class="header-anchor" href="#_8-如何处理重复消息-即消息幂等性保证"><span>8.如何处理重复消息？（即消息幂等性保证）</span></a></h2><p>处理RabbitMQ重复消息的问题，就是处理消息的业务逻辑保持幂等性，只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。</p><p>这个问题需要灵活作答，考察的是综合应用能力和经验，因为消费的场景有很多，有数据库、有缓存、有第三方接口。</p><div class="hint-container tip"><p class="hint-container-title">提示：总体上根据不同的业务增加去重逻辑，通常就是根据业务设置一个唯一标识，通过检测这个唯一标识是否已经处理过来处理去重问题。</p></div><p>例如：</p><ul><li>比如针对数据库，插入数据，可以通过唯一键，重复插入会报错，又或者插入之前先检测一下是否存在，针对更新操作，可以根据数据的状态判断是否已经处理过。</li><li>再比如redis缓存，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。</li><li>再比如第三方接口，接口需要有去重能力。</li></ul><h2 id="_9-如何确保消息正确地发送至rabbitmq" tabindex="-1"><a class="header-anchor" href="#_9-如何确保消息正确地发送至rabbitmq"><span>9.如何确保消息正确地发送至RabbitMQ？</span></a></h2><p>RabbitMQ支持<code>Confirm模式</code>，确认消息有没有安全的投递给RabbitMQ。</p><p>下面是大致原理：</p><p>将信道设置成 <code>confirm</code> 模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个<code>唯一的 ID</code>。</p><p>一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），<code>信道</code>会发送一个确认给生产者（包含消息唯一 ID）。</p><p>如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 <code>nack（notacknowledged，未确认）</code>消息。</p><p>发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。</p><h2 id="_10-如何确保消息接收方消费了消息" tabindex="-1"><a class="header-anchor" href="#_10-如何确保消息接收方消费了消息"><span>10.如何确保消息接收方消费了消息？</span></a></h2><p>消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ 才能安全地把消息从队列中删除。</p><div class="hint-container tip"><p class="hint-container-title">提示：RabbitMQ消费者消息确认（ACK）有两种机制，自动确认或者手动确认，自动确认就是消费者收到消息RabbitMQ就删除消息，手动确认，需要我们在代码层面主动调用Ack方法通知RabbitMQ，消息已经处理。</p></div><p>这里并没有用到超时机制，RabbitMQ 仅通过 Consumer 的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ 给了 Consumer 足够长的时间来处理消息。保证数据的最终一致性；</p><p>下面罗列几种特殊情况</p><ul><li>如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ 会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要去重）</li><li>如果消费者接收到消息却没有确认消息，连接也未断开，则 RabbitMQ 认为该消费者繁忙，将不会给该消费者分发更多的消息。</li></ul><h2 id="_11-如何确保消息不丢失" tabindex="-1"><a class="header-anchor" href="#_11-如何确保消息不丢失"><span>11.如何确保消息不丢失？</span></a></h2><p>RabbitMq如何确保消息不丢失？</p><p>RabbitMQ主要通过持久化机制，确保消息不丢，RabbitMQ持久化机制分为<code>队列持久化</code>、<code>消息持久化</code>、<code>交换器持久化</code>。</p><p>下面从多个方面确保消息不丢：</p><h3 id="消息持久化" tabindex="-1"><a class="header-anchor" href="#消息持久化"><span>消息持久化</span></a></h3><p><code>RabbitMQ 的消息默认存放在内存上面</code>，如果不特别声明，消息不会持久化保存到硬盘上面，如果节点重启或者意外crash掉，消息就会丢失。</p><p>要想做到消息持久化，必须满足以下三个条件：</p><ul><li><code>Exchange</code> 设置持久化</li><li><code>Queue</code> 设置持久化 -<code> Message</code>持久化发送：发送消息设置发送模式deliveryMode=2，代表持久化消息</li></ul><h3 id="消息ack机制" tabindex="-1"><a class="header-anchor" href="#消息ack机制"><span>消息ACK机制</span></a></h3><p>默认情况消费者收到消息，MQ就会从队列中删除消息，如果消费者没处理成功，消息就丢了，可以使用手动ACK机制，处理完成手动调用MQ的ACK方法通知MQ删除消息。</p><h3 id="rabbitmq集群模式" tabindex="-1"><a class="header-anchor" href="#rabbitmq集群模式"><span>RabbitMQ集群模式</span></a></h3><p>使用集群模式部署RabbitMQ,实现消息的高可用，避免单个MQ节点挂了，消息就没了。</p><h3 id="消息补偿" tabindex="-1"><a class="header-anchor" href="#消息补偿"><span>消息补偿</span></a></h3><p>有时候可能是因为消息过期（TTL）、或者消费者异常导致消息丢了，这个时候需要从业务数据角度，写个脚本重新生成消息，投递到消息队列中。</p><h2 id="_12-什么是延迟队列" tabindex="-1"><a class="header-anchor" href="#_12-什么是延迟队列"><span>12.什么是延迟队列？</span></a></h2><p>RabbitMQ延迟队列就是存储延迟消息的队列，延迟消息指的就是消息投递到队列后，消费者不能立刻消费，需要等待一段时间，消费者才能消费消息。</p><div class="hint-container tip"><p class="hint-container-title">提示：延迟队列，可以用来做定时任务。</p></div><p>RabbitMQ原生不支持延迟消息，目前主要通过死信交换机 + 消息TTL方案或者rabbitmq-delayed-message-exchange插件实现。</p><h2 id="_13-什么是死信队列" tabindex="-1"><a class="header-anchor" href="#_13-什么是死信队列"><span>13.什么是死信队列？</span></a></h2><p>DLX，全称为 Dead-Letter-Exchange，死信交换机，死信邮箱。当消息在一个队列中变成死信 (dead message) 之后，它能被重新被发送到另一个交换机中，这个交换机就是 DLX，绑定 DLX 的队列就称之为死信队列。</p><p>导致死信的原因：</p><ul><li>消息被拒（Basic.Reject /Basic.Nack) 且 requeue = false。</li><li>消息TTL过期。</li><li>队列满了，无法再添加。</li></ul><h2 id="_14-什么是优先级队列" tabindex="-1"><a class="header-anchor" href="#_14-什么是优先级队列"><span>14.什么是优先级队列？</span></a></h2><p>优先级队列，顾名思义，优先级高的消息具备优先被消费的特权。</p><p>RabbitMQ优先级队列注意点：</p><ul><li>只有当消费者不足，不能及时进行消费的情况下，优先级队列才会生效。</li><li>RabbitMQ3.5版本以后才支持优先级队列。</li></ul><h2 id="_15-如何解决消息积压" tabindex="-1"><a class="header-anchor" href="#_15-如何解决消息积压"><span>15.如何解决消息积压？</span></a></h2><p>如何解决RabbitMQ消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？数百万消息持续积压几个小时，说说怎么解决？</p><div class="hint-container tip"><p class="hint-container-title">提示：出现消息积压，主要是因为消息的消费速度跟不上消息产生的速度。</p></div><h3 id="消息堆积解决策略1" tabindex="-1"><a class="header-anchor" href="#消息堆积解决策略1"><span>消息堆积解决策略1</span></a></h3><p>消费者临时扩容，例如：原先是10个消费者，扩容10倍，100个消费者，目的是加快消息消费速度。</p><div class="hint-container tip"><p class="hint-container-title">提示：扩容数量根据实际情况确定。</p></div><h3 id="消息堆积解决策略2" tabindex="-1"><a class="header-anchor" href="#消息堆积解决策略2"><span>消息堆积解决策略2</span></a></h3><p>修复消费者问题，消费者本身的问题，主要体现在两个方面: 业务异常和消息处理速度慢。</p><ul><li>如果是消费者自己异常了，导致无法正常消费消息，只要修复异常问题即可。</li><li>如果是消费者处理速度慢，可以分析下业务代码有没有进一步提升性能的空间，有就优化，没有就走策略1扩容方案。</li></ul><h3 id="消息堆积解决策略3" tabindex="-1"><a class="header-anchor" href="#消息堆积解决策略3"><span>消息堆积解决策略3</span></a></h3><p>如果消息堆积的太多，短时间内消费不完（需要几个小时，甚至更长时间），可以做个取舍，反正前面的客户已经得罪了，新的客户不能得罪，我们可以确保新的消息可以正常消费，老的消息慢慢处理。</p><p>可以新开一个队列，让新的消息投递到这个队列，新开一批消费者，处理新的消息，老的队列里面堆积的消息，让一批消费者慢慢跑。</p><h3 id="消息堆积解决策略4" tabindex="-1"><a class="header-anchor" href="#消息堆积解决策略4"><span>消息堆积解决策略4</span></a></h3><p>如果堆积的消息不重要，直接干掉（删除）队列，创建新的队列，处理新的消息就行，不能在一棵树上吊死。</p><h3 id="消息堆积解决策略5" tabindex="-1"><a class="header-anchor" href="#消息堆积解决策略5"><span>消息堆积解决策略5</span></a></h3><p>如果消息设置了TTL，这种情况，消息可能因为已经到期，被丢弃了，丢了多少我们不知道，为确保业务消息都被正常消费，这里首先要决绝的是怎么找回丢失的消息，主要思路是根据业务数据，重新投递消息到MQ中，例如：根据订单记录，如果订单未处理，重新投递消息到消息队列。</p>',109)]))}const h=e(c,[["render",p]]),r=JSON.parse('{"path":"/interview/RabbitMQ/","title":"RabbitMQ","lang":"zh-CN","frontmatter":{"title":"RabbitMQ","createTime":"2025/07/07 16:41:56","permalink":"/interview/RabbitMQ/","description":"1.RabbitMQ核心概念有哪些？ Broker： 表示消息队列服务器 Exchange： 消息交换机，它指定消息按什么规则，路由到哪个队列 Queue： 消息队列载体，每个消息都会被投入到一个或多个队列 Binding： 绑定，它的作用就是把exchange和queue按照路由规则绑定起来 Routing Key： 路由关键字，exchange根据...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RabbitMQ\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-14T03:14:18.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://docs.sreio.com/interview/RabbitMQ/"}],["meta",{"property":"og:site_name","content":"Sreio Docs"}],["meta",{"property":"og:title","content":"RabbitMQ"}],["meta",{"property":"og:description","content":"1.RabbitMQ核心概念有哪些？ Broker： 表示消息队列服务器 Exchange： 消息交换机，它指定消息按什么规则，路由到哪个队列 Queue： 消息队列载体，每个消息都会被投入到一个或多个队列 Binding： 绑定，它的作用就是把exchange和queue按照路由规则绑定起来 Routing Key： 路由关键字，exchange根据..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-14T03:14:18.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-14T03:14:18.000Z"}]]},"readingTime":{"minutes":15.38,"words":4615},"git":{"createdTime":1751877858000,"updatedTime":1752462858000,"contributors":[{"name":"sreio","username":"sreio","email":"ingwei@163.com","commits":2,"avatar":"https://avatars.githubusercontent.com/sreio?v=4","url":"https://github.com/sreio"}],"changelog":[{"hash":"392e0717075550911bee8967562578d34bf94c89","time":1752462858000,"email":"ingwei@163.com","author":"sreio","message":"updated: fixed tip"},{"hash":"5be24b01f97e53b886885abde519c2e0cc6b3447","time":1751877858000,"email":"ingwei@163.com","author":"sreio","message":"面试"}]},"autoDesc":true,"filePathRelative":"interview/消息队列/1.RabbitMQ.md","headers":[]}');export{h as comp,r as data};
