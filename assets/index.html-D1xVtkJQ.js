import{_ as s,c as e,e as a,o as t}from"./app-DWByWgeb.js";const n="/assets/1-1-DVdo87b6.png",d="/assets/1-2-TQg3IdwO.png",l="/assets/1-3-CnxuLyiD.png",r="/assets/1-4-5T8M41fw.png",p={};function o(h,i){return t(),e("div",null,i[0]||(i[0]=[a('<h2 id="redis-为什么那么快" tabindex="-1"><a class="header-anchor" href="#redis-为什么那么快"><span>Redis 为什么那么快？</span></a></h2><p>除了它是内存数据库，使得所有的操作都在内存上进行之外，还有一个重要因素，它实现的数据结构，使得我们对数据进行增删查改操作时，Redis 能高效的处理。</p><h2 id="redis-数据类型对应数据结构" tabindex="-1"><a class="header-anchor" href="#redis-数据类型对应数据结构"><span>Redis 数据类型对应数据结构</span></a></h2><figure><img src="'+n+`" alt="" tabindex="0" loading="lazy" width="1352" height="830"><figcaption></figcaption></figure><p>可以看到，Redis 数据类型的底层数据结构随着版本的更新也有所不同，比如：</p><ul><li>在 Redis 3.0 版本中 List 对象的底层数据结构由「双向链表」或「压缩表列表」实现，但是在 3.2 版本之后，List 数据类型底层数据结构是由 quicklist 实现的；</li><li>在最新的 Redis 代码（还未发布正式版本）中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</li></ul><h2 id="键值对数据库是怎么实现的" tabindex="-1"><a class="header-anchor" href="#键值对数据库是怎么实现的"><span>键值对数据库是怎么实现的？</span></a></h2><p>在开始讲数据结构之前，先给介绍下 Redis 是怎样实现键值对（key-value）数据库的。</p><p>Redis 的键值对中的 key 就是字符串对象，而 <code>value 可以是字符串对象，也可以是集合数据类型的对象</code>，比如 List 对象、Hash 对象、Set 对象和 Zset 对象。</p><p>举个例子，我这里列出几种 Redis 新增键值对的命令：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> SET name </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">weidada</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">OK</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> HSET person name </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">weidada</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> age 18</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">0</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> RPUSH stu </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">weidada</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">sreio</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">integer</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> 4</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些命令代表着：</p><ul><li>第一条命令：name 是一个<code>字符串键</code>，因为键的值是一个<code>字符串对象</code>；</li><li>第二条命令：person 是一个<code>哈希表键</code>，因为键的值是一个<code>包含两个键值对的哈希表对象</code>；</li><li>第三条命令：stu 是一个<code>列表键</code>，因为键的值是一个<code>包含两个元素的列表对象</code>；</li></ul><h2 id="这些键值对是如何保存在-redis-中的呢" tabindex="-1"><a class="header-anchor" href="#这些键值对是如何保存在-redis-中的呢"><span>这些键值对是如何保存在 Redis 中的呢？</span></a></h2><p>Redis 是使用了一个「<code>哈希表</code>」保存所有键值对，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对。哈希表其实就是一个数组，数组中的元素叫做哈希桶。</p><h2 id="redis-的哈希桶是怎么保存键值对数据的呢" tabindex="-1"><a class="header-anchor" href="#redis-的哈希桶是怎么保存键值对数据的呢"><span>Redis 的哈希桶是怎么保存键值对数据的呢？</span></a></h2><p>哈希桶存放的是<code>指向键值对数据的指针（dictEntry*）</code>，这样通过指针就能找到键值对数据，然后因为键值对的值可以保存字符串对象和集合数据类型的对象，所以键值对的数据结构中并不是直接保存值本身，而是保存了 <code>void * key</code> 和 <code>void * value</code> 指针，分别指向了实际的<code>键对象</code>和<code>值对象</code>，这样一来，即使值是集合数据，也可以通过 <code>void * value</code> 指针找到。</p><p>我这里画了一张 Redis 保存键值对所涉及到的数据结构。</p><figure><img src="`+d+'" alt="" tabindex="0" loading="lazy" width="1637" height="662"><figcaption>:size=50%</figcaption></figure><p>这些数据结构的内部细节，我先不展开讲，后面在讲哈希表数据结构的时候，在详细的说说，因为用到的数据结构是一样的。这里先大概说下图中涉及到的数据结构的名字和用途：</p><ul><li>redisDb 结构，表示 Redis 数据库的结构，结构体里存放了指向了 dict 结构的指针；</li><li>dict 结构，结构体里存放了 2 个哈希表，正常情况下都是用「哈希表1」，「哈希表2」只有在 rehash 的时候才用，具体什么是 rehash，我在本文的哈希表数据结构会讲；</li><li>ditctht 结构，表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向一个哈希表节点结构（dictEntry）的指针；</li><li>dictEntry 结构，表示哈希表节点的结构，结构里存放了 **void * key 和 void * value 指针，<code> key 指向的是 String 对象，而 value 则可以指向 String 对象，也可以指向集合类型的对象，比如 List 对象、Hash 对象、Set 对象和 Zset 对象</code>。</li></ul><p>特别说明下，void * key 和 void * value 指针指向的是 Redis 对象，Redis 中的每个对象都由 redisObject 结构表示，如下图：</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy" width="647" height="587"><figcaption>:size=50%</figcaption></figure><p>对象结构里包含的成员变量：</p><ul><li>type，标识该对象是什么类型的对象（String 对象、 List 对象、Hash 对象、Set 对象和 Zset 对象）；</li><li>encoding，标识该对象使用了哪种底层的数据结构；</li><li>ptr，指向底层数据结构的指针。</li></ul><p>我画了一张 Redis 键值对数据库的全景图，你就能清晰知道 Redis 对象和数据结构的关系了：</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy" width="1889" height="684"><figcaption>:size=70%</figcaption></figure>',27)]))}const g=s(p,[["render",o]]),k=JSON.parse('{"path":"/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","title":"数据结构","lang":"zh-CN","frontmatter":{"title":"数据结构","createTime":"2025/07/07 17:53:09","permalink":"/redis/数据结构/","description":"Redis 为什么那么快？ 除了它是内存数据库，使得所有的操作都在内存上进行之外，还有一个重要因素，它实现的数据结构，使得我们对数据进行增删查改操作时，Redis 能高效的处理。 Redis 数据类型对应数据结构 可以看到，Redis 数据类型的底层数据结构随着版本的更新也有所不同，比如： 在 Redis 3.0 版本中 List 对象的底层数据结构由...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数据结构\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-29T16:03:14.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://docs.sreio.com/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],["meta",{"property":"og:site_name","content":"Sreio Docs"}],["meta",{"property":"og:title","content":"数据结构"}],["meta",{"property":"og:description","content":"Redis 为什么那么快？ 除了它是内存数据库，使得所有的操作都在内存上进行之外，还有一个重要因素，它实现的数据结构，使得我们对数据进行增删查改操作时，Redis 能高效的处理。 Redis 数据类型对应数据结构 可以看到，Redis 数据类型的底层数据结构随着版本的更新也有所不同，比如： 在 Redis 3.0 版本中 List 对象的底层数据结构由..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-29T16:03:14.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-29T16:03:14.000Z"}]]},"readingTime":{"minutes":3.84,"words":1153},"git":{"createdTime":1751885168000,"updatedTime":1767024194000,"contributors":[{"name":"sreio","username":"sreio","email":"ingwei@163.com","commits":2,"avatar":"https://avatars.githubusercontent.com/sreio?v=4","url":"https://github.com/sreio"}],"changelog":[{"hash":"6dd596b6752ea1c49be57e00b1b0c941c0324a5d","time":1767024194000,"email":"ingwei@163.com","author":"sreio","message":"feat: Add new documentation across Go, PHP, Docker, Linux, Database, Middleware, and Fundamentals, while removing some old images and files."},{"hash":"c1ab990bb57919c348cc77b4236368714def9959","time":1751885168000,"email":"ingwei@163.com","author":"sreio","message":"elk&#x26;clickhouse&#x26;redis&#x26;mongdb&#x26;etcd"}]},"autoDesc":true,"filePathRelative":"database/redis/2.数据结构/1.README.md","headers":[]}');export{g as comp,k as data};
