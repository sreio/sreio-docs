import{_ as i,c as t,e as o,o as a}from"./app-DDsjqNbb.js";const c="/assets/1-1-DIeBMwXX.png",n={};function r(p,e){return a(),t("div",null,e[0]||(e[0]=[o('<h3 id="rabbitmq概念示意图" tabindex="-1"><a class="header-anchor" href="#rabbitmq概念示意图"><span>RabbitMQ概念示意图</span></a></h3><figure><img src="'+c+'" alt="img" tabindex="0" loading="lazy" width="927" height="265"><figcaption>img</figcaption></figure><h3 id="概念解释" tabindex="-1"><a class="header-anchor" href="#概念解释"><span>概念解释</span></a></h3><ul><li><p><code>Message</code>: 消息，包含消息头（即附属的配置信息）和消息体（即消息内容）</p></li><li><p><code>Publisher</code>:消息的生产者，是一个向交换器发布消息的客户端应用程序</p></li><li><p><code>Exchange</code>:交换器，用来接收生产者发送的消息并且将这些消息路由给服务器中的队列</p><blockquote><p>四种Exchange类型:</p><ul><li><code>Direct类型</code>：将消息中的Routing key与该Exchange关联的所有Binding中的Routing key进行比较，如果相等，则发送到该Binding对应的Queue中</li><li><code>Topic 类型</code>：将消息中的Routing key与该Exchange关联的所有Binding中的Routing key进行对比，如果匹配上了，则发送到该Binding对应的Queue中。</li><li><code>Fanout 类型</code>：直接将消息转发到所有binding的对应queue中，这种exchange在路由转发的时候，忽略Routing key。</li><li><code>Headers 类型</code>：将消息中的headers与该Exchange相关联的所有Binging中的参数进行匹配，如果匹配上了，则发送到该Binding对应的Queue中（不常用，作用于Direct类型类似）。</li></ul><p>提示：Exchange类型后面的工作模式章节会有详细介绍，这里先有个概念。</p></blockquote></li><li><p><code>Binding</code>:绑定关系，用于建立消息队列和交换器之间的关系</p></li><li><p><code>Queue</code>:消息队列，用来保存消息直到发送给消费者，他是消息的容器，也是消息的终点。一个消息可投入一个或者多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走</p></li><li><p><code>Connection</code>:网络连接比如tcp连接</p></li><li><p><code>Channel</code>:信道，信道是建立在真实的TCP连接内地虚拟连接，AMQP命令都是通过信道发出去的，不管是发布消息，订阅队列，还是接受消息，这些动作都是在信道完成的。</p></li></ul><p>因为对于操作系统来说建立和销毁TCP都是非常安昂贵的开销，所以引入信道的概念，以此来复用一条TCP连接</p><ul><li><p><code>Consumer</code>:消息的消费者，表示一个从消息队列中取得消息的客户端应用程序</p></li><li><p><code>Virtual Host</code>:虚拟主机，表示一批交换机，消息队列和相关的对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。</p><p>每个vhost本质上就是一个mini版的RabbitMQ服务器，拥有自己的队列、交换器、绑定和权限机制。</p><p>vhost是AMQP概念的基础，必须在连接的时候指定，RabbitMQ默认的vhost是/</p><blockquote><p>提示：Virtual Host就是一种资源隔离策略，可以在同一个RabbitMQ中划分多个隔离的区域。</p></blockquote></li><li><p><code>Broker</code>:表示消息队列服务器实体</p></li></ul>',6)]))}const l=i(n,[["render",r]]),s=JSON.parse('{"path":"/queue/RabbitMQ/%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/","title":"核心概念","lang":"zh-CN","frontmatter":{"title":"核心概念","createTime":"2025/07/07 16:56:31","permalink":"/queue/RabbitMQ/核心概念/","description":"RabbitMQ概念示意图 imgimg 概念解释 Message: 消息，包含消息头（即附属的配置信息）和消息体（即消息内容） Publisher:消息的生产者，是一个向交换器发布消息的客户端应用程序 Exchange:交换器，用来接收生产者发送的消息并且将这些消息路由给服务器中的队列 四种Exchange类型: Direct类型：将消息中的Rout...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"核心概念\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-07T09:12:44.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://docs.sreio.com/queue/RabbitMQ/%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"}],["meta",{"property":"og:site_name","content":"Sreio Docs"}],["meta",{"property":"og:title","content":"核心概念"}],["meta",{"property":"og:description","content":"RabbitMQ概念示意图 imgimg 概念解释 Message: 消息，包含消息头（即附属的配置信息）和消息体（即消息内容） Publisher:消息的生产者，是一个向交换器发布消息的客户端应用程序 Exchange:交换器，用来接收生产者发送的消息并且将这些消息路由给服务器中的队列 四种Exchange类型: Direct类型：将消息中的Rout..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-07T09:12:44.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-07T09:12:44.000Z"}]]},"readingTime":{"minutes":2.38,"words":714},"git":{"createdTime":1751879564000,"updatedTime":1751879564000,"contributors":[{"name":"sreio","username":"sreio","email":"ingwei@163.com","commits":1,"avatar":"https://avatars.githubusercontent.com/sreio?v=4","url":"https://github.com/sreio"}],"changelog":[{"hash":"ec6b65d5f5e156de0bddee87610673d45a5591df","time":1751879564000,"email":"ingwei@163.com","author":"sreio","message":"queue"}]},"autoDesc":true,"filePathRelative":"queue/2.RabbitMQ教程/3.工作原理/1.核心概念.md","headers":[]}');export{l as comp,s as data};
