import{_ as t,c as a,e as o,o as i}from"./app-DWByWgeb.js";const r="/assets/3-1-B4NVsDyF.png",n={};function s(c,e){return i(),a("div",null,e[0]||(e[0]=[o('<p>RabbitMQ工作队列（Work模式），<code>一个生产者</code>，<code>多个消费者</code>，每条消息只能被一个消费者消费，支持并发消费消息。</p><div class="hint-container tip"><p class="hint-container-title">提示：Work模式，相对于简单队列来说就是支持并发消费消息，但是一条消息只能被一个消费者处理，因此Work模式也是一对一消费模式。</p></div><h3 id="架构图" tabindex="-1"><a class="header-anchor" href="#架构图"><span>架构图</span></a></h3><p>Work模式</p><figure><img src="'+r+'" alt="img" tabindex="0" loading="lazy" width="332" height="111"><figcaption>img</figcaption></figure><p>说明： P 代表生产者 , C1、C2 代表消费者，红色代表队列。</p><h3 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景"><span>应用场景</span></a></h3><p>单一业务，一对一并发处理，例如：群发邮件，需要发送1000封邮件，可以开启100个消费者，一次并发发送100封邮件。</p><div class="hint-container tip"><p class="hint-container-title">提示：在多个消费者并发消费同一个队列的消息的情况下，无法保证消息的严格顺序，例如：队列中有10条消息，有10个消费者并发处理10个消息，有些消费者执行快、有些执行慢点，这个时候会出现消息处理的顺序，跟队列中消息的顺序不一致，可能后面的消息先执行成功，前面的消息还在处理中，如果你的业务对消息的顺序有严格要求，可以控制每个队列只有一个消费者，这样就可以保证严格消息处理顺序，代价就是并发能力下降。</p></div>',9)]))}const p=t(n,[["render",s]]),m=JSON.parse('{"path":"/queue/RabbitMQ/Work%E9%98%9F%E5%88%97/","title":"工作模式-Work队列","lang":"zh-CN","frontmatter":{"title":"工作模式-Work队列","createTime":"2025/07/07 16:56:31","permalink":"/queue/RabbitMQ/Work队列/","description":"RabbitMQ工作队列（Work模式），一个生产者，多个消费者，每条消息只能被一个消费者消费，支持并发消费消息。 提示：Work模式，相对于简单队列来说就是支持并发消费消息，但是一条消息只能被一个消费者处理，因此Work模式也是一对一消费模式。 架构图 Work模式 imgimg 说明： P 代表生产者 , C1、C2 代表消费者，红色代表队列。 应...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"工作模式-Work队列\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-29T16:03:14.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://docs.sreio.com/queue/RabbitMQ/Work%E9%98%9F%E5%88%97/"}],["meta",{"property":"og:site_name","content":"Sreio Docs"}],["meta",{"property":"og:title","content":"工作模式-Work队列"}],["meta",{"property":"og:description","content":"RabbitMQ工作队列（Work模式），一个生产者，多个消费者，每条消息只能被一个消费者消费，支持并发消费消息。 提示：Work模式，相对于简单队列来说就是支持并发消费消息，但是一条消息只能被一个消费者处理，因此Work模式也是一对一消费模式。 架构图 Work模式 imgimg 说明： P 代表生产者 , C1、C2 代表消费者，红色代表队列。 应..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-29T16:03:14.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-29T16:03:14.000Z"}]]},"readingTime":{"minutes":1.23,"words":370},"git":{"createdTime":1751879564000,"updatedTime":1767024194000,"contributors":[{"name":"sreio","username":"sreio","email":"ingwei@163.com","commits":2,"avatar":"https://avatars.githubusercontent.com/sreio?v=4","url":"https://github.com/sreio"}],"changelog":[{"hash":"6dd596b6752ea1c49be57e00b1b0c941c0324a5d","time":1767024194000,"email":"ingwei@163.com","author":"sreio","message":"feat: Add new documentation across Go, PHP, Docker, Linux, Database, Middleware, and Fundamentals, while removing some old images and files."},{"hash":"ec6b65d5f5e156de0bddee87610673d45a5591df","time":1751879564000,"email":"ingwei@163.com","author":"sreio","message":"queue"}]},"autoDesc":true,"filePathRelative":"middleware/queue/2.RabbitMQ教程/3.工作原理/3.工作模式-Work队列.md","headers":[]}');export{p as comp,m as data};
