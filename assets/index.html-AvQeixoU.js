import{_ as s,c as e,e as a,o as t}from"./app-DDsjqNbb.js";const n="/assets/3_1-CHmG_NxH.png",d="/assets/3_2-FW1KuNsC.png",o={};function l(c,i){return t(),e("div",null,i[0]||(i[0]=[a('<p>提到事务，你肯定不陌生，和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转 账，你要给朋友小王转100块钱，而此时你的银行卡只有100块钱。</p><p>转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必 须保证是一体的，不然等程序查完之后，还没做减法之前，你这100块钱，完全可以借着这个时 间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事 务”这个概念了。</p><p>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事 务支持是在引擎层实现的。你现在知道，MySQL是一个支持多引擎的系统，但并不是所有的引 擎都支持事务。比如MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代 的重要原因之一。</p><p>今天的文章里，我将会以InnoDB为例，剖析MySQL在事务支持方面的特定实现，并基于原理给 出相应的实践建议，希望这些案例能加深你对MySQL事务原理的理解。</p><h2 id="隔离性与隔离级别" tabindex="-1"><a class="header-anchor" href="#隔离性与隔离级别"><span>隔离性与隔离级别</span></a></h2><p>提到事务，你肯定会想到<code>ACID</code>（<code>Atomicity</code>、<code>Consistency</code>、<code>Isolation</code>、<code>Durability</code>，即原子性、一 致性、隔离性、持久性），今天我们就来说说其中<code>I</code>，也就是“隔离性”。</p><p>当数据库上有多个事务同时执行的时候，就可能出现脏读（<code>dirty read</code>）、不可重复读（<code>non-repeatable read</code>）、幻读（<code>phantomread</code>）的问题，为了解决这些问题，就有了“隔离级别”的概 念。</p><p>在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要 在二者之间寻找一个平衡点。SQL标准的事务隔离级别包括：读未提交（<code>read uncommitted</code>）、 读提交（<code>read committed</code>）、可重复读（<code>repeatable read</code>）和串行化（<code>serializable</code> ）。下面我逐 一为你解释：</p><ul><li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一 致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突 的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><p>其中“读提交”和“可重复读”比较难理解，所以我用一个例子说明这几种隔离级别。假设数据表T中 只有一列，其中一行的值为1，下面是按照时间顺序执行两个事务的行为</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">mysql</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> create</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> table</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> T(c </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">) engine</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">InnoDB; </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">insert into</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> T(c) </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">values</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><figure><img src="'+n+`" alt="3-1" tabindex="0" loading="lazy" width="970" height="1128"><figcaption>:size=60%</figcaption></figure><p>我们来看看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3 的返回值分别是什么。</p><ul><li>若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被 A看到了。因此，V2、V3也都是2。</li><li>若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。</li><li>若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求： 事务在执行期间看到的数据前后必须是一致的。</li><li>若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后， 事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。</li></ul><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离 级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级 别下，这个视图是在每个<code>SQL</code>语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离 级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避 免并行访问。</p><p>我们可以看到在不同的隔离级别下，数据库行为是有所不同的。<code>Oracle</code>数据库的默认隔离级别其 实就是“读提交”，因此对于一些从<code>Oracle</code>迁移到<code>MySQL</code>的应用，为保证数据库隔离级别的一致， 你一定要记得将<code>MySQL</code>的隔离级别设置为“读提交”。</p><p>配置的方式是，将启动参数<code>transaction-isolation</code>的值设置成<code>READ-COMMITTED</code>。你可以用 <code>showvariables</code>来查看当前的值</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">mysql</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> show variables </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">like</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">transaction_isolation</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">; </span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">-----------------------+----------------+ </span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">| Variable_name | </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">Value</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> | </span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">-----------------------+----------------+ </span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">| transaction_isolation | </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">READ</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">COMMITTED</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> | </span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">-----------------------+----------------+</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。</p><p>我想 你可能会问那什么时候需要 <code>可重复读</code> 的场景呢 ？我们来看一个数据校对逻辑的案例。</p><p>假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时 候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。 你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p><p>这时候使用<code>可重复读</code>隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务 更新的影响。</p><h2 id="事务隔离的实现" tabindex="-1"><a class="header-anchor" href="#事务隔离的实现"><span>事务隔离的实现</span></a></h2><p>理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复读”。</p><p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通 过回滚操作，都可以得到前一个状态的值。</p><p>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。</p><figure><img src="`+d+'" alt="3-2" tabindex="0" loading="lazy" width="1228" height="782"><figcaption>:size=100%</figcaption></figure><p>当前值是<strong>4</strong>，但是在查询这条记录的时候，不同时刻启动的事务会有不同的<code>read-view</code>。如图中看 到的，在视图<code>A</code>、<code>B</code>、<code>C</code>里面，这一个记录的值分别是<strong>1</strong>、<strong>2</strong>、<strong>4</strong>，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（<code>MVCC</code>）。对于<code>read-viewA</code>，要得到<strong>1</strong>，就必须将当前 值依次执行图中所有的回滚操作得到。</p><p>同时你会发现，即使现在有另外一个事务正在将<strong>4</strong>改成<strong>5</strong>，这个事务跟<code>read-viewA</code>、<code>B</code>、<code>C</code>对应的 事务是不会冲突的。</p><p>你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。</p><p>也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p><p>什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的<code>read-view</code>的时候。 基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。</p><p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><p>在<code>MySQL 5.5</code>及以前的版本，回滚日志是跟数据字典一起放在<code>ibdata</code>文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有<code>20GB</code>，而回滚段有<code>200GB</code>的库。最终 只好为了清理回滚段，重建整个库。</p><p>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。</p><h2 id="事务的启动方式" tabindex="-1"><a class="header-anchor" href="#事务的启动方式"><span>事务的启动方式</span></a></h2><p>如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并 不是有意使用长事务，通常是由于误用所致。<code>MySQL</code>的事务启动方式有以下几种：</p><ol><li><p>显式启动事务语句， <code>begin</code> 或 <code>start transaction</code>。配套的提交语句是<code>commit</code>，回滚语句是 <code>rollback</code>。</p></li><li><p><code>set autocommit=0</code>，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个<code>select</code>语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 <code>commit</code> 或 <code>rollback</code> 语句，或者断开连接。</p></li></ol><p>有些客户端连接框架会默认连接成功后先执行一个<code>set autocommit=0</code>的命令。这就导致接下来的 查询都在事务中，如果是长连接，就导致了意外的长事务。</p><p>因此，我会建议你总是使用<code>set autocommit=1</code>, 通过显式语句的方式来启动事务。</p><p>但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式 每个事务在开始时都不需要主动执行一次 <code>begin</code>，减少了语句的交互次数。如果你也有这个顾 虑，我建议你使用<code>commit work and chain</code>语法。</p><p>在<code>autocommit</code>为<code>1</code>的情况下，用<code>begin</code>显式启动的事务，如果执行<code>commit</code>则提交事务。如果执行 <code>commit work and chain</code>，则是提交事务并自动启动下一个事务，这样也省去了再次执行<code>begin</code>语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p><p>你可以在<code>information_schema</code>库的<code>innodb_trx</code>这个表中查询<code>长事务</code>，比如下面这个语句，用于查找持续时间超过<code>60s</code>的事务。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">select</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> from</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> information_schema</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">innodb_trx</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> where</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> TIME_TO_SEC(timediff(</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">now</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">,trx_started))</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">60</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><p>这篇文章里面，我介绍了<code>MySQL</code>的事务隔离级别的现象和实现，根据实现原理分析了长事务存 在的风险，以及如何用正确的方式避免长事务。希望我举的例子能够帮助你理解事务，并更好地 使用<code>MySQL</code>的事务特性。</p>',46)]))}const h=s(o,[["render",l]]),r=JSON.parse('{"path":"/mysql/Mysql45%E8%AE%B2/sql_transaction/","title":"事务隔离：为什么你改了我还看不见？","lang":"zh-CN","frontmatter":{"title":"事务隔离：为什么你改了我还看不见？","createTime":"2025/07/07 17:59:50","permalink":"/mysql/Mysql45讲/sql_transaction/","description":"提到事务，你肯定不陌生，和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转 账，你要给朋友小王转100块钱，而此时你的银行卡只有100块钱。 转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必 须保证是一体的，不然等程序查完之后，还没做减法之前，你这100块钱，完全可以借着这个时 间差再查一次，然后再给另外一...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"事务隔离：为什么你改了我还看不见？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-07T10:46:08.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://docs.sreio.com/mysql/Mysql45%E8%AE%B2/sql_transaction/"}],["meta",{"property":"og:site_name","content":"Sreio Docs"}],["meta",{"property":"og:title","content":"事务隔离：为什么你改了我还看不见？"}],["meta",{"property":"og:description","content":"提到事务，你肯定不陌生，和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转 账，你要给朋友小王转100块钱，而此时你的银行卡只有100块钱。 转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必 须保证是一体的，不然等程序查完之后，还没做减法之前，你这100块钱，完全可以借着这个时 间差再查一次，然后再给另外一..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-07T10:46:08.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-07T10:46:08.000Z"}]]},"readingTime":{"minutes":9.55,"words":2865},"git":{"createdTime":1751885168000,"updatedTime":1751885168000,"contributors":[{"name":"sreio","username":"sreio","email":"ingwei@163.com","commits":1,"avatar":"https://avatars.githubusercontent.com/sreio?v=4","url":"https://github.com/sreio"}],"changelog":[{"hash":"c1ab990bb57919c348cc77b4236368714def9959","time":1751885168000,"email":"ingwei@163.com","author":"sreio","message":"elk&#x26;clickhouse&#x26;redis&#x26;mongdb&#x26;etcd"}]},"autoDesc":true,"filePathRelative":"mysql/2.Mysql45讲/3.sql_transaction.md","headers":[]}');export{h as comp,r as data};
