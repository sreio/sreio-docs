import{_ as l}from"./1_1-DH_LRomf.js";import{_ as n,c as h,e as a,b as e,d as i,a as d,w as k,r as p,o}from"./app-DDsjqNbb.js";const r="/assets/1_2-umCBuS3l.png",c={};function g(y,s){const t=p("VPLink");return o(),h("div",null,[s[9]||(s[9]=a('<ul><li>比如，你有个最简 单的表，表里只有一个ID字段，在执行下面这个查询语句时：</li></ul><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">select</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> from</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> T </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">where</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ID</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">10</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">；</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>MySQL的基本架构示意图</li></ul><figure><img src="'+l+`" alt="1-1" tabindex="0" loading="lazy" width="1346" height="1008"><figcaption>1-1</figcaption></figure><blockquote><p><code>Server层</code>包括<code>连接器</code>、<code>查询缓存</code>、<code>分析器</code>、<code>优化器</code>、<code>执行器</code>等，涵盖MySQL的大多数核心服务 功能，以及所有的<code>内置函数</code>（如日期、时间、数学和加密函数等），所有跨<code>存储引擎</code>的功能都在 这一层实现，比如<code>存储过程</code>、<code>触发器</code>、<code>视图</code>等。</p></blockquote><blockquote><p>而<code>存储引擎层</code>负责数据的存储和提取。其架构模式是插件式的，支持<code>InnoDB</code>、<code>MyISAM</code>、 <code>Memory</code>等多个存储引擎。现在最常用的存储引擎是<code>InnoDB</code>，它从<code>MySQL 5.5.5</code>版本开始成为了 默认存储引擎。</p></blockquote><h2 id="_1-连接器" tabindex="-1"><a class="header-anchor" href="#_1-连接器"><span>1.连接器</span></a></h2><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。<code>连接器</code>负责跟客户端建立连 接、获取权限、维持和管理连接。连接命令一般是这么写的:</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">mysql</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -h</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">$ip</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -P</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">$port</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -u</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">$user</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -p</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">  </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">//</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 完成经典的TCP握手后</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">//</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">      *</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 如果用户名或密码不对，你就会收到一个</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Access denied for user</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">的错误，然后客户端程序</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 结束执行。</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">//</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">//</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 修改完成后，只有再新建的连接才会使用新的权限设置。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,9)),e("p",null,[s[1]||(s[1]=i("连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在")),d(t,{href:"/mysql/Mysql%E5%AE%9E%E8%B7%B5%E6%8A%80%E5%B7%A7/processlist.md"},{default:k(()=>s[0]||(s[0]=[i("show full processlist")])),_:1,__:[0]}),s[2]||(s[2]=i("命令中看到它。文本中这个图是 ")),s[3]||(s[3]=e("code",null,"show full processlist",-1)),s[4]||(s[4]=i(" 的结果，其中的 ")),s[5]||(s[5]=e("code",null,"Command",-1)),s[6]||(s[6]=i(" 列显示为 “")),s[7]||(s[7]=e("code",null,"Sleep",-1)),s[8]||(s[8]=i("” 的这 一行，就表示现在系统里面有一个空闲连接。"))]),s[10]||(s[10]=a('<figure><img src="'+r+`" alt="1_2" tabindex="0" loading="lazy" width="875" height="163"><figcaption>1_2</figcaption></figure><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 <code>wait_timeout</code> 控制的，默认值是8小时。</p><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： <code>Lost connection to MySQL server during query</code>。这时候如果你要继续，就需要重连，然后再执行请求了。</p><blockquote><p><code>长连接</code>是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。 <code>短连接</code>则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p></blockquote><p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是 尽量使用长连接。</p><p>但是全部使用长连接后，你可能会发现，有些时候<code>MySQL</code>占用内存涨得特别快，这是因为<code>MySQL</code>在执行过程中临时使用的<code>内存</code>是管理在<code>连接对象</code>里面的。这些资源会在<code>连接断开</code>的时候才释放。所以如果长连接累积下来，可能导致<code>内存占用太大</code>，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p><p>解决方案：</p><ul><li><p><code>定期断开</code>长连接。使用一段时间，或者程序里面判断执行过一个<code>占用内存的大查询</code>后，断开 连接，之后要查询再重连。</p></li><li><p>如果你用的是<code>MySQL 5.7</code>或更新版本，可以在每次执行一个比较大的操作后，通过执行 <code>mysql_reset_connection</code>来重新初始化连接资源。这个过程不需要<code>重连</code>和重新做<code>权限验证</code>， 但是会将连接恢复到刚刚创建完时的状态。</p></li></ul><h2 id="_2-查询缓存" tabindex="-1"><a class="header-anchor" href="#_2-查询缓存"><span>2.查询缓存</span></a></h2><p><code>MySQL</code>拿到一个查询请求后，会先到<code>查询缓存</code>看看，之前是不是执行过这条语句。之前执行过 的语句及其结果可能会以<code>key-value</code>对的形式，被直接缓存在内存中。<code>key</code>是查询的语句，<code>value</code>是查询的结果。如果你的查询能够直接在这个缓存中找到<code>key</code>，那么这个<code>value</code>就会被直接返回给客户端。</p><p>如果语句不在<code>查询缓存</code>中，就会继续后面的执行阶段。执行完成后，执行结果会被存入<code>查询缓存</code>中。</p><div class="hint-container tip"><p class="hint-container-title"><strong>大多数情况不建议使用查询缓存，查询缓存弊大于利。</strong> 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。</p></div><p>对于更新压力大的数据库 来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。 比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p>好在MySQL也提供了这种“按需使用”的方式。你可以将参数<code>query_cache_type</code>设置成 <code>DEMAND</code>，这样对于默认的<code>SQL</code>语句都不使用<code>查询缓存</code>。而对于你确定要使用查询缓存的语句，可以用<code>SQL_CACHE</code>显式指定，像下面这个语句一样：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">select</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> SQL_CACHE </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> from</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> T </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">where</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ID</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">10</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">；</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">需要注意的是，<code>MySQL 8.0</code>版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有 这个功能了。</p></div><h2 id="_3-分析器" tabindex="-1"><a class="header-anchor" href="#_3-分析器"><span>3.分析器</span></a></h2><p>如果没有命中查询缓存，就要开始真正执行语句了。</p><p>分析器先会做“<code>词法分析</code>”。你输入的是由多个字符串和空格组成的一条<code>SQL</code>语句，<code>MySQ</code>L需要识别出里面的字符串分别是什么，代表什么。</p><p><code>MySQL</code>从你输入的&quot;<code>select</code>&quot;这个关键字识别出来，这是一个<code>查询语句</code>。 它也要把字符串“<code>T</code>”识别 成“<code>表名T</code>”，把字符串“<code>ID</code>”识别成“<code>列ID</code>”。 做完了这些识别以后，就要做“<code>语法分析</code>”。根据词法分析的结果，语法分析器会根据语法规则， 判断你输入的这个<code>SQL语句</code>是否满足<code>MySQL语法</code>。 如果你的语句不对，就会收到“<code>You have an error in your SQL syntax</code>”的错误提醒，比如下面这个 语句<code>select</code>少打了开头的字母“<code>s</code>”。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">select</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> from</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> t </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">where</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ID</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">//</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ERROR </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1064</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> (</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">42000</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">): You have an error </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">in</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> your </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SQL</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> syntax; </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">check</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> the </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">manual</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> that corresponds </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">to</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“<code>use near</code>”的内容。</p><h2 id="_4-优化器" tabindex="-1"><a class="header-anchor" href="#_4-优化器"><span>4.优化器</span></a></h2><p><code>优化器</code>是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联<code>join</code>的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的<code>join</code>：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">select</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> from</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> t1 </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">join</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> t2 </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">using</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">(ID) </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">where</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> t1</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">c</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">10</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> and</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> t2</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">d</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">20</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><p>既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</p></li><li><p>也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</p></li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><h2 id="_5-执行器" tabindex="-1"><a class="header-anchor" href="#_5-执行器"><span>5.执行器</span></a></h2><p>开始执行的时候，要先判断一下你对这个表T有没有执行<code>查询的权限</code>，如果没有，就会返回没有权限的错误，如下所示。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">select</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> from</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> T </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">where</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ID</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">10</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">//</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ERROR </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1142</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> (</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">42000</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">): </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SELECT</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> command denied </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">to</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> user </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">b</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">@</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">localhost</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> for</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> table</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">T</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个<code>引擎</code>提供的接口</p><p>比如我们这个例子中的表T中，ID字段<code>没有索引</code>，那么执行器的<code>执行流程</code>是这样的：</p><ol><li>调用<code>InnoDB</code>引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中</li><li>调用<code>引擎接口</code>取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有<code>满足条件的行</code>组成的记录集作为<code>结果集</code>返回给客户端。至此，这个语句就执行完成了</li></ol><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p><p>你会在数据库的慢查询日志中看到一个<code>rows_examined</code>的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><div class="hint-container tip"><p class="hint-container-title">在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟<code>rows_examined</code>并不是完全相同的。</p></div>`,36))])}const u=n(c,[["render",g]]),m=JSON.parse('{"path":"/mysql/Mysql45%E8%AE%B2/sql_select/","title":"一条SQL查询语句是如何执行的？","lang":"zh-CN","frontmatter":{"title":"一条SQL查询语句是如何执行的？","createTime":"2025/07/07 17:58:10","permalink":"/mysql/Mysql45讲/sql_select/","description":"比如，你有个最简 单的表，表里只有一个ID字段，在执行下面这个查询语句时： MySQL的基本架构示意图 1-11-1 Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务 功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在 这一层实现，比如存储过程、触发器、视图等。 而存储引擎层...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"一条SQL查询语句是如何执行的？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-14T03:14:18.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://docs.sreio.com/mysql/Mysql45%E8%AE%B2/sql_select/"}],["meta",{"property":"og:site_name","content":"Sreio Docs"}],["meta",{"property":"og:title","content":"一条SQL查询语句是如何执行的？"}],["meta",{"property":"og:description","content":"比如，你有个最简 单的表，表里只有一个ID字段，在执行下面这个查询语句时： MySQL的基本架构示意图 1-11-1 Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务 功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在 这一层实现，比如存储过程、触发器、视图等。 而存储引擎层..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-14T03:14:18.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-14T03:14:18.000Z"}]]},"readingTime":{"minutes":7.82,"words":2345},"git":{"createdTime":1751885168000,"updatedTime":1752462858000,"contributors":[{"name":"sreio","username":"sreio","email":"ingwei@163.com","commits":3,"avatar":"https://avatars.githubusercontent.com/sreio?v=4","url":"https://github.com/sreio"}],"changelog":[{"hash":"392e0717075550911bee8967562578d34bf94c89","time":1752462858000,"email":"ingwei@163.com","author":"sreio","message":"updated: fixed tip"},{"hash":"3d222b039475f57e6ed877bb33887f0f72a005f7","time":1751885456000,"email":"ingwei@163.com","author":"sreio","message":"fixed"},{"hash":"c1ab990bb57919c348cc77b4236368714def9959","time":1751885168000,"email":"ingwei@163.com","author":"sreio","message":"elk&#x26;clickhouse&#x26;redis&#x26;mongdb&#x26;etcd"}]},"autoDesc":true,"filePathRelative":"mysql/2.Mysql45讲/1.sql_select.md","headers":[]}');export{u as comp,m as data};
