import{_ as i,c as a,e as n,o as e}from"./app-DDsjqNbb.js";const l="/assets/1-1-Co5ylM6J.png",h={};function t(p,s){return e(),a("div",null,s[0]||(s[0]=[n('<h2 id="_1-什么是适配器模式" tabindex="-1"><a class="header-anchor" href="#_1-什么是适配器模式"><span>1. 什么是适配器模式</span></a></h2><h3 id="_1-1-定义" tabindex="-1"><a class="header-anchor" href="#_1-1-定义"><span>1.1 定义</span></a></h3><p>适配器模式是一种结构型设计模式，它允许将一个类的接口转换成客户端所期望的另一个接口。适配器模式使得那些原本由于接口不兼容而不能一起工作的类可以协同工作。</p><h3 id="_1-2-目的和作用" tabindex="-1"><a class="header-anchor" href="#_1-2-目的和作用"><span>1.2 目的和作用</span></a></h3><p>适配器模式的主要目的是解决两个不兼容接口之间的兼容性问题。通过使用适配器类，可以使得不兼容的两个类能够合作进行某个特定功能的实现。</p><h3 id="_1-3-适配器模式的基本原则" tabindex="-1"><a class="header-anchor" href="#_1-3-适配器模式的基本原则"><span>1.3 适配器模式的基本原则</span></a></h3><ul><li>将接口转换成另一个接口时，适配器模式适用于处理已存在的类。</li><li>适配器模式通过创建一个适配器类来实现接口转换，而不是修改原有的类。</li><li>适配器模式可以通过类适配器或对象适配器来实现。</li></ul><h2 id="_2-适配器模式的特点和优点" tabindex="-1"><a class="header-anchor" href="#_2-适配器模式的特点和优点"><span>2. 适配器模式的特点和优点</span></a></h2><p>适配器模式具有以下特点和优点：</p><ul><li>提供了接口转换的解决方案，使得不兼容的类能够一起工作。</li><li>可以增加系统的灵活性和可扩展性。</li><li>可以复用已存在的类，减少代码重复和开发成本。</li><li>提供了一种松耦合的设计方案，使得系统更加灵活和易于维护。</li></ul><h2 id="_3-适配器模式的应用场景" tabindex="-1"><a class="header-anchor" href="#_3-适配器模式的应用场景"><span>3. 适配器模式的应用场景</span></a></h2><p>适配器模式在以下场景中常被使用：</p><ul><li>当需要使用一个已经存在的类，但其接口不符合需求时。</li><li>当需要创建一个可以复用的类，该类能够与不兼容的接口一起工作。</li><li>当需要在多个类之间进行接口转换时。</li></ul><h2 id="_4-golang中的适配器模式实现" tabindex="-1"><a class="header-anchor" href="#_4-golang中的适配器模式实现"><span>4. Golang中的适配器模式实现</span></a></h2><h3 id="_4-1-uml类图" tabindex="-1"><a class="header-anchor" href="#_4-1-uml类图"><span>4.1 UML类图</span></a></h3><figure><img src="'+l+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_4-2-实现步骤1-设计适配器接口" tabindex="-1"><a class="header-anchor" href="#_4-2-实现步骤1-设计适配器接口"><span>4.2 实现步骤1: 设计适配器接口</span></a></h3><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-go"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">package</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> main</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">type</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Target</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> interface</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    Request</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-3-实现步骤2-实现适配器类" tabindex="-1"><a class="header-anchor" href="#_4-3-实现步骤2-实现适配器类"><span>4.3 实现步骤2: 实现适配器类</span></a></h3><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-go"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">package</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> main</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">type</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Adaptee</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> struct</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">func</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">a </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">Adaptee</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> SpecificRequest</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 实现适配者类的具体功能</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">type</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Adapter</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> struct</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">    adaptee</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">Adaptee</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">func</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> NewAdapter</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">Adapter</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &amp;</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">Adapter</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">adaptee</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &amp;</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">Adaptee</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{}}</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">func</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">a </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">Adapter</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Request</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">    a</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">adaptee</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">SpecificRequest</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-4-实现步骤3-客户端代码调用适配器模式" tabindex="-1"><a class="header-anchor" href="#_4-4-实现步骤3-客户端代码调用适配器模式"><span>4.4 实现步骤3: 客户端代码调用适配器模式</span></a></h3><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-go"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">package</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> main</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">func</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> main</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">    adapter</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> :=</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> NewAdapter</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">    adapter</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Request</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_5-适配器模式的进阶应用" tabindex="-1"><a class="header-anchor" href="#_5-适配器模式的进阶应用"><span>5. 适配器模式的进阶应用</span></a></h2><h3 id="_5-1-适配器模式与桥接模式的区别与联系" tabindex="-1"><a class="header-anchor" href="#_5-1-适配器模式与桥接模式的区别与联系"><span>5.1 适配器模式与桥接模式的区别与联系</span></a></h3><p>适配器模式和桥接模式都可以用于处理两个不同类的接口问题，但它们的主要区别在于：</p><ul><li>适配器模式主要关注的是两个已经存在的接口之间的兼容性转换。</li><li>桥接模式主要关注的是抽象与实现的分离，通过接口和实现类之间的桥接来实现解耦。</li></ul><h3 id="_5-2-适配器模式在微服务架构中的应用" tabindex="-1"><a class="header-anchor" href="#_5-2-适配器模式在微服务架构中的应用"><span>5.2 适配器模式在微服务架构中的应用</span></a></h3><p>在微服务架构中，不同的微服务可能使用不同的接口进行通信。适配器模式可以帮助我们解决不同服务之间的接口兼容性问题，使得它们可以协同工作。</p><h3 id="_5-3-适配器模式在前后端分离开发中的应用" tabindex="-1"><a class="header-anchor" href="#_5-3-适配器模式在前后端分离开发中的应用"><span>5.3 适配器模式在前后端分离开发中的应用</span></a></h3><p>前后端分离开发中，前端通常需要从后端获取数据，而后端暴露的接口可能不符合前端的需求。适配器模式可以帮助我们将后端的接口适配成前端所期望的接口，实现前后端的无缝协作。</p>`,30)]))}const k=i(h,[["render",t]]),r=JSON.parse('{"path":"/golang/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","title":"适配器模式","lang":"zh-CN","frontmatter":{"title":"适配器模式","createTime":"2025/07/08 09:45:34","permalink":"/golang/设计模式/适配器模式/","description":"1. 什么是适配器模式 1.1 定义 适配器模式是一种结构型设计模式，它允许将一个类的接口转换成客户端所期望的另一个接口。适配器模式使得那些原本由于接口不兼容而不能一起工作的类可以协同工作。 1.2 目的和作用 适配器模式的主要目的是解决两个不兼容接口之间的兼容性问题。通过使用适配器类，可以使得不兼容的两个类能够合作进行某个特定功能的实现。 1.3 适...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"适配器模式\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-08T02:28:08.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://docs.sreio.com/golang/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"}],["meta",{"property":"og:site_name","content":"Sreio Docs"}],["meta",{"property":"og:title","content":"适配器模式"}],["meta",{"property":"og:description","content":"1. 什么是适配器模式 1.1 定义 适配器模式是一种结构型设计模式，它允许将一个类的接口转换成客户端所期望的另一个接口。适配器模式使得那些原本由于接口不兼容而不能一起工作的类可以协同工作。 1.2 目的和作用 适配器模式的主要目的是解决两个不兼容接口之间的兼容性问题。通过使用适配器类，可以使得不兼容的两个类能够合作进行某个特定功能的实现。 1.3 适..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-08T02:28:08.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-08T02:28:08.000Z"}]]},"readingTime":{"minutes":2.97,"words":890},"git":{"createdTime":1751941688000,"updatedTime":1751941688000,"contributors":[{"name":"sreio","username":"sreio","email":"ingwei@163.com","commits":1,"avatar":"https://avatars.githubusercontent.com/sreio?v=4","url":"https://github.com/sreio"}],"changelog":[{"hash":"d57fb21cb27927b0c89eb7f1047937b7a671c0a1","time":1751941688000,"email":"ingwei@163.com","author":"sreio","message":"go"}]},"autoDesc":true,"filePathRelative":"golang/2.设计模式/2.结构型模式/1.适配器模式.md","headers":[]}');export{k as comp,r as data};
