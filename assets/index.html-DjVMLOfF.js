import{_ as i,c as l,e as a,o}from"./app-DDsjqNbb.js";const t="/assets/dc-DSJReGOC.png",c={};function p(r,e){return o(),l("div",null,e[0]||(e[0]=[a('<h2 id="php垃圾回收机制-gc" tabindex="-1"><a class="header-anchor" href="#php垃圾回收机制-gc"><span>PHP垃圾回收机制（GC）</span></a></h2><ul><li><ol><li>使用 引用计数机制</li></ol></li><li><ol start="2"><li>将每个 PHP 变量保存在一个叫 zval 变量容器中。</li></ol></li><li><ol start="3"><li>zval 变量容器 包含 变量的类型、变量值、 is_res、refcount</li></ol></li><li><ol start="4"><li><code>is_ref</code> 用于标识该变量是否为引用集合或变量。</li></ol></li><li><ol start="5"><li>refcount 表示指向当前变量的个数。</li></ol></li><li><ol start="6"><li>默认打开垃圾回收机制, 当发现有存在循环引用的zval时, 就会把其投入到根缓冲区, 当根缓冲区达到配置文件中的指定数量后, 就会进行垃圾回收, 以此解决8. 循环引用导致的内存泄露问题</li></ol></li><li><ol start="7"><li>如果引用计数减少到零, 所在变量容器将被清除（free）, 不属于垃圾；</li></ol></li><li><ol start="8"><li>如果一个zval的引用计数减少后还大于0, 那么它会进入垃圾周期。</li></ol></li><li><ol start="9"><li>其次, 在一个垃圾周期中, 通过检查引用计数是否减1, 并且检查哪些变量容器的引用次数是零, 来发现哪部分是垃圾。</li></ol></li></ul><h2 id="php底层原理" tabindex="-1"><a class="header-anchor" href="#php底层原理"><span>PHP底层原理</span></a></h2><h3 id="php代码执行过程" tabindex="-1"><a class="header-anchor" href="#php代码执行过程"><span>PHP代码执行过程：</span></a></h3><ol><li>启动 php 及 zend 引擎</li><li>加载注册拓展模块</li><li>对代码进行词法/语法分析</li><li>编译成opcode(opcache)</li><li>执行 opcode</li></ol><h3 id="php-的四层体系-从下至上分为四层" tabindex="-1"><a class="header-anchor" href="#php-的四层体系-从下至上分为四层"><span>PHP 的四层体系, 从下至上分为四层:</span></a></h3><ul><li>Zend 引擎 <ul><li>Zend 引擎整体用C语言实现，是 PHP 的内核部分，它负责将 PHP 代码翻译（词法、语法解析等一系列编译过程）为可执行的 opcode 操作码，并实现相应的处理方法、基本的数据结构（如 hashtable、OO）、内存分配及管理、提供相应的 API 方法供外部调用。</li></ul></li><li>扩展层 <ul><li>围绕着 Zend 引擎，Extensions 通过组件化的方式提供各种基础服务，我们常见的各种内置函数（例如变量操作函数、字符串操作函数等）以及标准库等都是通过 Extensions 来实现。</li></ul></li><li>SAPI（服务器应用程序编程接口） <ul><li>SAPI 通过一系列钩子函数，使得 PHP 可以和外围交互数据，这是 PHP 非常优雅和成功的一个设计，通过 SAPI 成功的将 PHP 本身和上层应用解耦隔离，PHP 可以不再考虑如何针对不同应用进行兼容，而应用本身也可以针对自己的特点实现不同的处理方式。</li></ul></li><li>Application（上层应用）</li></ul><figure><img src="'+t+'" alt="img" tabindex="0" loading="lazy" width="476" height="500"><figcaption>:size=50%</figcaption></figure><h2 id="php运行模式以及各自的原理" tabindex="-1"><a class="header-anchor" href="#php运行模式以及各自的原理"><span>PHP运行模式以及各自的原理</span></a></h2><h3 id="先了解一下-cgi" tabindex="-1"><a class="header-anchor" href="#先了解一下-cgi"><span>先了解一下 CGI :</span></a></h3><ul><li>CGI（Common Gateway Interface）全称是“通用网关接口”，是一种让 客户端 与 Web服务器 程序进行通信（数据传输）的协议。</li><li>CGI 用来规范 Web服务器 传输到 解析器(例: php-cgi) 中的数据类型以及数据格式，包括URL、查询字符串、POST数据、HTTP header等。</li><li>解析器只要符合 CGI 标准，就能作为一个 cgi 程序与 Web 服务器交互。</li><li>一次请求都要 fork 一个进程, 然后销毁，也就是（fork-and-execute）模式，性能较低。</li></ul><h4 id="php-运行模式" tabindex="-1"><a class="header-anchor" href="#php-运行模式"><span>PHP 运行模式:</span></a></h4><ul><li><p>FastCGI</p><ul><li>FastCGI（Fast Common Gateway Interface）全称是“快速通用网关接口”，也是一种让 客户端 与 Web服务器 程序进行通信（数据传输）的协议。。</li><li><code>FastCGI</code> 是 <code>CGI</code> 模式的升级版, 目的是避免重复解析配置文件和初始执行环境。</li><li>像是一个常驻型 <code>CGI</code> , 可以一直处理请求不结束该进程。</li><li>多进程，将比 <code>CGI</code> 消耗更多的服务器内存。</li><li>可平滑停止/启动进程。</li></ul></li><li><p>PHPCGI</p><ul><li>一个 <code>CGI</code> 程序，是 PHP 实现 <code>CGI</code> 的 PHP解析器。</li><li>用于解析请求，返回结果。</li><li>不可平滑重启。</li></ul></li><li><p>PHP-FPM</p><ul><li><code>PHP-FPM</code> 为 <code>FastCGI</code> 的进程管理器。</li><li>工作原理为:</li><li>Web 服务器启动时，加载启动 <code>PHP-FPM</code>，<code>PHP-FPM</code> 读取配置文件，初始化运行环境。</li><li><code>PHP-FPM</code> 创建一个 Master 主进程和若干个 Worker 进程，负责监听端口，等待接收请求，每个进程内都调用一个 <code>PHP-CGI</code>。</li><li>用户发起请求, Web服务器接收请求并转发给 <code>PHP-FPM</code>，空闲的 Worker 进程以抢占式的接收该请求。</li><li>监听接收后，<code>PHPCGI</code> 解析请求，开始执行业务处理代码, 处理完成后，按照 CGI 规定的格式返给 Worker 进程, 然后退出进程, 此时 Worker 进程变成空闲状态等待下次请求。</li><li>Worker 进程将结果返给 Web服务器, Web服务器接收返回内容并返回给客户端。</li></ul></li><li><p>MODULE</p><ul><li><code>apache + php</code> 运行时，默认使用的是 <code>module 模式</code>，它把 php 作为 <code>apache</code> 的模块随 <code>apache</code> 启动而启动，接收到用户请求时则直接通过调用 <code>mod_php 模块</code> 进行处理。</li></ul></li><li><p>PHP-CLI</p><ul><li><code>PHP-CLI 模式</code> 属于命令行模式</li><li>在终端直接输入 <code>php 文件名.php</code> 就可直接运行代码</li><li>没有超时时间</li><li><code>echo</code>、<code>var_dump</code>、<code>phpinfo</code> 等输出会直接打印到控制台中</li></ul></li></ul><h2 id="php-数组底层原理" tabindex="-1"><a class="header-anchor" href="#php-数组底层原理"><span>PHP 数组底层原理</span></a></h2><ol><li><p>底层实现是通过散列表（hash table） + 双向链表（解决hash冲突）</p><ol><li>hashtable：将不同的关键字（key）通过映射函数计算得到散列值（Bucket-&gt;h） 从而直接索引到对应的Bucket</li><li>hash表保存当前循环的指针, 所以foreach 比for更快</li><li>Bucket：保存数组元素的key和value, 以及散列值h</li></ol></li><li><p>如何保证有序性</p><ol><li>散列函数和元素数组（Bucket）中间添加一层大小和存储元素数组相同的映射表。</li><li>用于存储元素在实际存储数组中的下标</li><li>元素按照映射表的先后顺序插入实际存储数组中</li><li>映射表只是原理上的思路, 实际上并不会有实际的映射表, 而是初始化的时候分配Bucket内存的同时, 还会分配相同数量的 uint32_t 大小的空间, 然后将 arData 偏移到存储元素数组的位置。</li></ol></li><li><p>解决hash重复(php使用的链表法)：</p><ol><li>链表法:不同关键字指向同一个单元时, 使用链表保存关键字（遍历链表匹配key）</li><li>开放寻址法：当关键字指向已经存在数据的单元的时候, 继续寻找其他单元, 直到找到可用单元（占用其他单元位置, 更容易出现hash冲突, 性能下降）</li></ol></li><li><p>基础知识</p><ol><li>链表：队列、栈、双向链表</li><li>链表：元素 + 指向下一元素的指针</li><li>双向链表：指向上一元素的指针 + 元素 + 指向下一元素的指针</li></ol></li></ol><h2 id="依赖注入实现方式" tabindex="-1"><a class="header-anchor" href="#依赖注入实现方式"><span>依赖注入实现方式</span></a></h2><ol><li>构造函数依赖注入（如果依赖的类多，就会造成构造函数的形参特别多）</li><li>set 方式注入（如果依赖的类多，那 set 的方法也特别多）</li><li>采用类似 Laravel 服务容器 实现依赖注入（调用时使用闭包，这样就做到 使用才实例化）</li></ol><h2 id="php-内存溢出解决" tabindex="-1"><a class="header-anchor" href="#php-内存溢出解决"><span>PHP 内存溢出解决</span></a></h2><ol><li>增加 PHP 可用内存大小</li><li>对大数组分批处理或 yield 处理</li><li>及时销毁大数组或变量</li><li>根据业务规则，尽可能的少用 静态变量</li><li>数据库操作完，及时关闭</li></ol>',19)]))}const d=i(c,[["render",p]]),h=JSON.parse('{"path":"/interview/php/%E8%BF%9B%E9%98%B6%E7%AF%87/","title":"进阶篇","lang":"zh-CN","frontmatter":{"title":"进阶篇","createTime":"2025/07/07 16:17:42","permalink":"/interview/php/进阶篇/","description":"PHP垃圾回收机制（GC） 使用 引用计数机制 将每个 PHP 变量保存在一个叫 zval 变量容器中。 zval 变量容器 包含 变量的类型、变量值、 is_res、refcount is_ref 用于标识该变量是否为引用集合或变量。 refcount 表示指向当前变量的个数。 默认打开垃圾回收机制, 当发现有存在循环引用的zval时, 就会把其投入...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"进阶篇\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-07T08:48:09.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://docs.sreio.com/interview/php/%E8%BF%9B%E9%98%B6%E7%AF%87/"}],["meta",{"property":"og:site_name","content":"Sreio Docs"}],["meta",{"property":"og:title","content":"进阶篇"}],["meta",{"property":"og:description","content":"PHP垃圾回收机制（GC） 使用 引用计数机制 将每个 PHP 变量保存在一个叫 zval 变量容器中。 zval 变量容器 包含 变量的类型、变量值、 is_res、refcount is_ref 用于标识该变量是否为引用集合或变量。 refcount 表示指向当前变量的个数。 默认打开垃圾回收机制, 当发现有存在循环引用的zval时, 就会把其投入..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-07T08:48:09.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-07T08:48:09.000Z"}]]},"readingTime":{"minutes":6.12,"words":1837},"git":{"createdTime":1751877858000,"updatedTime":1751878089000,"contributors":[{"name":"sreio","username":"sreio","email":"ingwei@163.com","commits":2,"avatar":"https://avatars.githubusercontent.com/sreio?v=4","url":"https://github.com/sreio"}],"changelog":[{"hash":"066c6248983ad7feba746c5bfc01203e48752ed3","time":1751878089000,"email":"ingwei@163.com","author":"sreio","message":"面试"},{"hash":"5be24b01f97e53b886885abde519c2e0cc6b3447","time":1751877858000,"email":"ingwei@163.com","author":"sreio","message":"面试"}]},"autoDesc":true,"filePathRelative":"interview/PHP/2.进阶篇.md","headers":[]}');export{d as comp,h as data};
