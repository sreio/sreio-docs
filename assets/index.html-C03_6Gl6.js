import{_ as i,c as t,e as o,o as a}from"./app-DDsjqNbb.js";const n="data:image/png;base64,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",c="/assets/4-2-FC8i1bcY.png",d="/assets/4-3-3Wsq7Rey.png",p="/assets/4-4-C24SIS6H.png",s="/assets/4-5-BGFxLzBC.png",l="/assets/4-6-CckTlEZ2.png",r={};function g(h,e){return a(),t("div",null,e[0]||(e[0]=[o('<p>压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。</p><p>但是，压缩列表的缺陷也是有的：</p><ul><li>不能保存过多的元素，否则查询效率就会降低；</li><li>新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。</li></ul><p>因此，Redis 对象（List 对象、Hash 对象、Zset 对象）包含的元素数量较少，或者元素值不大的情况才会使用压缩列表作为底层数据结构。</p><p>接下来，就跟大家详细聊下压缩列表。</p><h2 id="压缩列表结构设计" tabindex="-1"><a class="header-anchor" href="#压缩列表结构设计"><span>压缩列表结构设计</span></a></h2><p>压缩列表是 Redis 为了节约内存而开发的，它是由连续内存块组成的顺序型数据结构，有点类似于数组。</p><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy" width="962" height="62"><figcaption>:size=50%</figcaption></figure><p>压缩列表在表头有三个字段：</p><ul><li><code>zlbytes</code>，记录整个压缩列表占用对内存字节数；</li><li><code>zltail</code>，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；</li><li><code>zllen</code>，记录压缩列表包含的节点数量；</li><li><code>zlend</code>，标记压缩列表的结束点，固定值 0xFF（十进制255）。</li></ul><p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段（zllen）的长度直接定位，复杂度是 O(1)。而<code>查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素</code>。</p><p>另外，压缩列表节点（entry）的构成如下：</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy" width="962" height="302"><figcaption>:size=50%</figcaption></figure><p>压缩列表节点包含三部分内容：</p><ul><li><code>prevlen</code>，记录了「前一个节点」的长度，目的是为了实现从后向前遍历；</li><li><code>encoding</code>，记录了当前节点实际数据的「类型和长度」，类型主要有两种：字符串和整数。</li><li><code>data</code>，记录了当前节点的实际数据，类型和长度都由 encoding 决定；</li></ul><p>当我们往压缩列表中插入数据时，压缩列表就会根据数据类型是字符串还是整数，以及数据的大小，会使用不同空间大小的 prevlen 和 encoding 这两个元素里保存的信息，<code>这种根据数据大小和类型进行不同的空间大小分配的设计思想，正是 Redis 为了节省内存而采用的</code>。</p><p>分别说下，prevlen 和 encoding 是如何根据数据的大小和类型来进行不同的空间大小分配。</p><p>压缩列表里的每个节点中的 prevlen 属性都记录了「前一个节点的长度」，而且 prevlen 属性的空间大小跟前一个节点长度值有关，比如：</p><p>如果<code>前一个节点的长度小于 254 字节</code>，那么 prevlen 属性需要用 <code>1 字节的空间</code>来保存这个长度值； 如果<code>前一个节点的长度大于等于 254 字节</code>，那么 prevlen 属性需要用 <code>5 字节的空间</code>来保存这个长度值；</p><p>encoding 属性的空间大小跟数据是字符串还是整数，以及字符串的长度有关，如下图（下图中的 content 表示的是实际数据，即本文的 data 字段）：</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy" width="1675" height="851"><figcaption>:size=50%</figcaption></figure><ul><li>如果<code>当前节点的数据是整数</code>，则 encoding 会使用 <code>1 字节的空间</code>进行编码，也就是 encoding 长度为 1 字节。通过 encoding 确认了整数类型，就可以确认整数数据的实际大小了，比如如果 encoding 编码确认了数据是 int16 整数，那么 data 的长度就是 int16 的大小。</li><li>如果<code>当前节点的数据是字符串，根据字符串的长度大小</code>，encoding 会使用<code> 1 字节/2字节/5字节的空间</code>进行编码，encoding 编码的前两个 bit 表示数据的类型，后续的其他 bit 标识字符串数据的实际长度，即 data 的长度。</li></ul><h2 id="连锁更新" tabindex="-1"><a class="header-anchor" href="#连锁更新"><span>连锁更新</span></a></h2><p>压缩列表除了查找复杂度高的问题，还有一个问题。</p><div class="hint-container tip"><p class="hint-container-title">压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降。</p></div><p>前面提到，压缩列表节点的 prevlen 属性会根据前一个节点的长度进行不同的空间大小分配：</p><ul><li>如果前一个<code>节点的长度小于 254 字节</code>，那么 prevlen 属性需要用<code> 1 字节的空间</code>来保存这个长度值；</li><li>如果前一个<code>节点的长度大于等于 254 字节</code>，那么 prevlen 属性需要用 <code>5 字节的空间</code>来保存这个长度值；</li></ul><p>现在假设一个压缩列表中有多个连续的、长度在 250～253 之间的节点，如下图：</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy" width="962" height="144"><figcaption>:size=50%</figcaption></figure><p>因为这些节点长度值小于 254 字节，所以 prevlen 属性需要用 1 字节的空间来保存这个长度值。</p><p>这时，如果将一个长度大于等于 254 字节的新节点加入到压缩列表的表头节点，即新节点将成为 e1 的前置节点，如下图：</p><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy" width="1082" height="204"><figcaption>:size=50%</figcaption></figure><p>因为 e1 节点的 prevlen 属性只有 1 个字节大小，无法保存新节点的长度，此时就需要对压缩列表的空间重分配操作，并将 e1 节点的 prevlen 属性从原来的 1 字节大小扩展为 5 字节大小。</p><p>多米诺牌的效应就此开始。</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy" width="1082" height="782"><figcaption>:size=50%</figcaption></figure><p>e1 原本的长度在 250～253 之间，因为刚才的扩展空间，此时 e1 的长度就大于等于 254 了，因此原本 e2 保存 e1 的 prevlen 属性也必须从 1 字节扩展至 5 字节大小。</p><p>正如扩展 e1 引发了对 e2 扩展一样，扩展 e2 也会引发对 e3 的扩展，而扩展 e3 又会引发对 e4 的扩展.... 一直持续到结尾。</p><p><code>这种在特殊情况下产生的连续多次空间扩展操作就叫做「连锁更新」</code>，就像多米诺牌的效应一样，第一张牌倒下了，推动了第二张牌倒下；第二张牌倒下，又推动了第三张牌倒下....，</p><h2 id="压缩列表的缺陷" tabindex="-1"><a class="header-anchor" href="#压缩列表的缺陷"><span>压缩列表的缺陷</span></a></h2><p>空间扩展操作也就是重新分配内存，因此<code>连锁更新一旦发生，就会导致压缩列表占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能</code>。</p><p>所以说，<code>虽然压缩列表紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，会导致内存重新分配，最糟糕的是会有「连锁更新」的问题</code>。</p><p>因此，<code>压缩列表只会用于保存的节点数量不多的场景</code>，只要节点数量足够小，即使发生连锁更新，也是能接受的。</p><p>虽说如此，Redis 针对压缩列表在设计上的不足，在后来的版本中，新增设计了两种数据结构：quicklist（Redis 3.2 引入） 和 listpack（Redis 5.0 引入）。这两种数据结构的设计目标，就是尽可能地保持压缩列表节省内存的优势，同时解决压缩列表的「连锁更新」的问题。</p>',43)]))}const u=i(r,[["render",g]]),f=JSON.parse('{"path":"/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/","title":"压缩列表","lang":"zh-CN","frontmatter":{"title":"压缩列表","createTime":"2025/07/07 18:04:06","permalink":"/redis/数据结构/压缩列表/","description":"压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。 但是，压缩列表的缺陷也是有的： 不能保存过多的元素，否则查询效率就会降低； 新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。 因此...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"压缩列表\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-14T03:14:18.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://docs.sreio.com/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/"}],["meta",{"property":"og:site_name","content":"Sreio Docs"}],["meta",{"property":"og:title","content":"压缩列表"}],["meta",{"property":"og:description","content":"压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。 但是，压缩列表的缺陷也是有的： 不能保存过多的元素，否则查询效率就会降低； 新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。 因此..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-14T03:14:18.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-14T03:14:18.000Z"}]]},"readingTime":{"minutes":6.67,"words":2001},"git":{"createdTime":1751885168000,"updatedTime":1752462858000,"contributors":[{"name":"sreio","username":"sreio","email":"ingwei@163.com","commits":2,"avatar":"https://avatars.githubusercontent.com/sreio?v=4","url":"https://github.com/sreio"}],"changelog":[{"hash":"392e0717075550911bee8967562578d34bf94c89","time":1752462858000,"email":"ingwei@163.com","author":"sreio","message":"updated: fixed tip"},{"hash":"c1ab990bb57919c348cc77b4236368714def9959","time":1751885168000,"email":"ingwei@163.com","author":"sreio","message":"elk&#x26;clickhouse&#x26;redis&#x26;mongdb&#x26;etcd"}]},"autoDesc":true,"filePathRelative":"redis/2.数据结构/4.压缩列表.md","headers":[]}');export{u as comp,f as data};
