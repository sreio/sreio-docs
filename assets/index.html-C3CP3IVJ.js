import{_ as s,c as a,e,o as n}from"./app-DWByWgeb.js";const t="/assets/3-1-D4GY-ke6.png",l="/assets/3-2-CYwxjjsU.png",h={};function p(d,i){return n(),a("div",null,i[0]||(i[0]=[e(`<p>大家最熟悉的数据结构除了数组之外，我相信就是链表了。</p><p>Redis 的 List 对象的底层实现之一就是链表。C 语言本身没有链表这个数据结构的，所以 Redis 自己设计了一个链表数据结构</p><h2 id="链表节点结构设计" tabindex="-1"><a class="header-anchor" href="#链表节点结构设计"><span>链表节点结构设计</span></a></h2><p>先来看看「链表节点」结构的样子：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">typedef</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> struct</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> listNode </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    //前置节点</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    struct</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> listNode </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">prev</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    //后置节点</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    struct</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> listNode </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    //节点的值</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    void</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">value</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> listNode</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有前置节点和后置节点，可以看的出，这个是一个双向链表。</p><figure><img src="`+t+`" alt="" tabindex="0" loading="lazy" width="1127" height="272"><figcaption>:size=50%</figcaption></figure><h2 id="链表结构设计" tabindex="-1"><a class="header-anchor" href="#链表结构设计"><span>链表结构设计</span></a></h2><p>不过，Redis 在 listNode 结构体基础上又封装了 list 这个数据结构，这样操作起来会更方便，链表结构如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">typedef</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> struct</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> list </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    //链表头节点</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    listNode </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">head</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    //链表尾节点</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    listNode </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">tail</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    //节点值复制函数</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    void</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">dup</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">void</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">ptr</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    //节点值释放函数</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    void</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">free</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">void</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">ptr</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    //节点值比较函数</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    int</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">match</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">void</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">ptr</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">key</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    //链表节点数量</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    unsigned</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> long</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> len</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> list</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>list 结构为链表提供了链表头指针 head、链表尾节点 tail、链表节点数量 len、以及可以自定义实现的 dup、free、match 函数。</p><p>举个例子，下面是由 list 结构和 3 个 listNode 结构组成的链表。</p><figure><img src="`+l+'" alt="" tabindex="0" loading="lazy" width="1449" height="512"><figcaption>:size=50%</figcaption></figure><h2 id="链表的优势与缺陷" tabindex="-1"><a class="header-anchor" href="#链表的优势与缺陷"><span>链表的优势与缺陷</span></a></h2><h3 id="redis-的链表实现优点如下" tabindex="-1"><a class="header-anchor" href="#redis-的链表实现优点如下"><span>Redis 的链表实现优点如下：</span></a></h3><ul><li>listNode 链表节点的结构里带有 prev 和 next 指针，获取<code>某个节点的前置节点或后置节点的时间复杂度只需O(1)，而且这两个指针都可以指向 NULL，所以链表是无环链表</code>；</li><li>list 结构因为提供了表头指针 head 和表尾节点 tail，所以<code>获取链表的表头节点和表尾节点的时间复杂度只需O(1)</code>；</li><li>list 结构因为提供了链表节点数量 len，所以<code>获取链表中的节点数量的时间复杂度只需O(1)</code>；</li><li>listNode 链表节使用 void* 指针保存节点值，并且可以通过 list 结构的 dup、free、match 函数指针为节点设置该节点类型特定的函数，因此<code>链表节点可以保存各种不同类型的值</code>；</li></ul><h3 id="链表的缺陷也是有的" tabindex="-1"><a class="header-anchor" href="#链表的缺陷也是有的"><span>链表的缺陷也是有的：</span></a></h3><ul><li>链表每个节点之间的内存都是不连续的，意味着<code>无法很好利用 CPU 缓存</code>。能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问。</li><li>还有一点，保存一个链表节点的值都需要一个链表节点结构头的分配，<code>内存开销较大</code>。</li></ul><p>因此，Redis 3.0 的 List 对象在数据量比较少的情况下，会采用「压缩列表」作为底层数据结构的实现，它的优势是节省内存空间，并且是内存紧凑型的数据结构。</p><p>不过，压缩列表存在性能问题（具体什么问题，下面会说），所以 Redis 在 3.2 版本设计了新的数据结构 quicklist，并将 List 对象的底层数据结构改由 quicklist 实现。</p><p>然后在 Redis 5.0 设计了新的数据结构 listpack，沿用了压缩列表紧凑型的内存布局，最终在最新的 Redis 版本，将 Hash 对象和 Zset 对象的底层数据结构实现之一的压缩列表，替换成由 listpack 实现。</p>',21)]))}const r=s(h,[["render",p]]),c=JSON.parse('{"path":"/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/","title":"链表","lang":"zh-CN","frontmatter":{"title":"链表","createTime":"2025/07/07 18:04:06","permalink":"/redis/数据结构/链表/","description":"大家最熟悉的数据结构除了数组之外，我相信就是链表了。 Redis 的 List 对象的底层实现之一就是链表。C 语言本身没有链表这个数据结构的，所以 Redis 自己设计了一个链表数据结构 链表节点结构设计 先来看看「链表节点」结构的样子： 有前置节点和后置节点，可以看的出，这个是一个双向链表。 :size=50% 链表结构设计 不过，Redis 在 ...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"链表\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-29T16:03:14.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://docs.sreio.com/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"}],["meta",{"property":"og:site_name","content":"Sreio Docs"}],["meta",{"property":"og:title","content":"链表"}],["meta",{"property":"og:description","content":"大家最熟悉的数据结构除了数组之外，我相信就是链表了。 Redis 的 List 对象的底层实现之一就是链表。C 语言本身没有链表这个数据结构的，所以 Redis 自己设计了一个链表数据结构 链表节点结构设计 先来看看「链表节点」结构的样子： 有前置节点和后置节点，可以看的出，这个是一个双向链表。 :size=50% 链表结构设计 不过，Redis 在 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-29T16:03:14.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-29T16:03:14.000Z"}]]},"readingTime":{"minutes":2.94,"words":882},"git":{"createdTime":1751885168000,"updatedTime":1767024194000,"contributors":[{"name":"sreio","username":"sreio","email":"ingwei@163.com","commits":2,"avatar":"https://avatars.githubusercontent.com/sreio?v=4","url":"https://github.com/sreio"}],"changelog":[{"hash":"6dd596b6752ea1c49be57e00b1b0c941c0324a5d","time":1767024194000,"email":"ingwei@163.com","author":"sreio","message":"feat: Add new documentation across Go, PHP, Docker, Linux, Database, Middleware, and Fundamentals, while removing some old images and files."},{"hash":"c1ab990bb57919c348cc77b4236368714def9959","time":1751885168000,"email":"ingwei@163.com","author":"sreio","message":"elk&#x26;clickhouse&#x26;redis&#x26;mongdb&#x26;etcd"}]},"autoDesc":true,"filePathRelative":"database/redis/2.数据结构/3.链表.md","headers":[]}');export{r as comp,c as data};
